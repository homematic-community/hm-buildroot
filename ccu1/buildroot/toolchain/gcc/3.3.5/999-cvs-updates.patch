Index: ChangeLog
===================================================================
RCS file: /cvs/gcc/gcc/ChangeLog,v
retrieving revision 1.621.2.52
retrieving revision 1.621.2.53
diff -u -r1.621.2.52 -r1.621.2.53
--- gcc/ChangeLog	30 Sep 2004 16:47:59 -0000	1.621.2.52
+++ gcc/ChangeLog	6 Oct 2004 12:00:52 -0000	1.621.2.53
@@ -1,3 +1,7 @@
+2004-10-06  Josef Zlomek  <josef.zlomek@email.cz>
+
+	* MAINTAINERS: Update my e-mail address.
+
 2004-09-30  Release Manager
 
 	* GCC 3.3.5 Released.
Index: MAINTAINERS
===================================================================
RCS file: /cvs/gcc/gcc/MAINTAINERS,v
retrieving revision 1.253.2.18
retrieving revision 1.253.2.19
diff -u -r1.253.2.18 -r1.253.2.19
--- gcc/MAINTAINERS	16 Jan 2004 23:33:12 -0000	1.253.2.18
+++ gcc/MAINTAINERS	6 Oct 2004 12:00:53 -0000	1.253.2.19
@@ -258,7 +258,7 @@
 John Wehle					john@feith.com
 Florian Weimer					fw@deneb.enyo.de
 Mark Wielaard					mark@gcc.gnu.org
-Josef Zlomek					zlomekj@suse.cz
+Josef Zlomek					josef.zlomek@email.cz
 
 GNATS only accounts
 
Index: gcc/ChangeLog
===================================================================
RCS file: /cvs/gcc/gcc/gcc/ChangeLog,v
retrieving revision 1.16114.2.1019
retrieving revision 1.16114.2.1059
diff -u -r1.16114.2.1019 -r1.16114.2.1059
--- gcc/gcc/ChangeLog	30 Sep 2004 16:45:01 -0000	1.16114.2.1019
+++ gcc/gcc/ChangeLog	29 Jan 2005 11:53:57 -0000	1.16114.2.1059
@@ -1,3 +1,314 @@
+2005-01-29  Alan Modra  <amodra@bigpond.net.au>
+
+	* unwind-dw2.c (execute_stack_op): Add missing cases for
+	DW_OP_shl, DW_OP_shr, DW_OP_shra, DW_OP_xor.
+
+2005-01-28  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/15384
+	* config/m68hc11/t-m68hc11-gas (dp-bit.c): Fix typo causing a
+	configuration part of dp-bit.c to be lost.
+
+2005-01-27  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	PR target/17771
+	Backport from mainline:
+	* config/s390/s390.md ("reload_outti"): Remove predicate for
+	output operand.  Abort if operand is not a MEM.
+	("reload_outdi", "reload_outdf"): Likewise.
+
+2005-01-22  Roger Sayle  <roger@eyesopen.com>
+
+	PR target/18402
+	Backport from mainline
+	2003-02-05  Jakub Jelinek  <jakub@redhat.com>
+ 
+ 	PR optimization/8555
+ 	* config/i386/i386.md (sse_mov?fcc split): Handle op2 == op3 case
+ 	instead of aborting.
+
+2005-01-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>
+
+	* gccbug.in: Update optimization -> tree-optimization/rtl-optimization.
+
+2005-01-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>
+
+	PR c++/17115
+	* tree-inline.c (expand_call_inline): Do not warn for functions
+	marked with attribute noinline.
+
+2005-01-18  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR rtl-optimization/19296
+	* combine.c (simplify_comparison): Rewrite the condition under
+	which a non-paradoxical SUBREG of a PLUS can be lifted when
+	compared against a constant.
+
+2004-01-14  David Mosberger  <davidm@hpl.hp.com>
+	    James E Wilson  <wilson@specifixinc.com>
+
+	PR target/18987
+	* config/ia64/ia64.c (process_set): For alloc insn, only call
+	process_epilogue is !frame_pointer_needed.
+
+	PR target/13158
+	* config/ia64/ia64.c (ia64_expand_epilogue): Set RTX_FRAME_RELATED_P on
+	sibcall alloc instruction.
+	(process_set): Handle sibcall alloc instruction.
+
+2005-01-13  David O'Brien  <obrien@FreeBSD.org>
+
+	Backport from mainline:
+	* config/freebsd-spec.h:  Use KSE pthread lib for -pthread.
+
+2005-01-08  Sergey M. Samoylov  <ssamoylov@dev.rtsoft.ru>
+
+	Backport:
+	2004-02-12  Richard Sandiford  <rsandifo@redhat.com>
+	PR bootstrap/13617
+	* config/mips/mips-protos.h (mips_output_aligned_decl_common): Declare.
+	(mips_declare_object): Make variadic.
+	* config/mips/mips.h (ASM_OUTPUT_ALIGNED_DECL_COMMON): Use
+	mips_output_aligned_decl_common.
+	* config/mips/mips.c (mips_output_aligned_decl_common): New function.
+	(mips_declare_object): Make variadic.
+
+2005-01-08  Richard Sandiford  <rsandifo@redhat.com>
+
+	PR target/17565
+	* config/mips/mips.md (define_asm_attributes): Set can_delay to no.
+
+2004-12-27 John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* vax.c (vax_address_cost, vax_rtx_cost): Correct casts.
+	(vax_rtx_cost): Handle small offsets for both PLUS and MINUS.
+
+2004-12-27  Steven Bosscher  <stevenb@suse.de>
+	    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	rtl-optimization/12863
+        * config/vax/vax.h (CASE_DROPS_THROUGH): Don't define.
+        * config/vax/vax.md (casesi): Emit a test-and-branch to make sure
+        that the case is in range, to make sure the casesi insn is always
+        in range and never falls through.
+        (casesi1): Add comment to explain why casesi never falls through.
+        Remove the unnamed special case casesi pattern.
+
+2004-12-26  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/17643
+	* config/pa/pa32-linux.h (FUNCTION_OK_FOR_SIBCALL): Return false when
+	TARGET_PORTABLE_RUNTIME is true.
+
+2004-12-25  Alan Modra  <amodra@bigpond.net.au>
+
+	PR target/19147
+	* config/rs6000/rs6000.md (andsi3_internal7, andsi3_internal8): Delete.
+
+2004-12-21  Joseph S. Myers  <jsm@polyomino.org.uk>
+
+	PR c/14765
+	* c-parse.in (compstmt_primary_start): Set last_expr_type to
+	NULL_TREE.
+
+2004-12-19  Roger Sayle  <roger@eyesopen.com>
+
+	PR middle-end/19068
+	* expr.c (expand_expr_real_1) <MAX_EXPR>: Ensure that target, op0
+	and op1 are all registers (or constants) before expanding the RTL
+	comparison sequence [to avoid reg_overlap_mentioned (target, op1)].
+
+2004-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/18882
+	* function.c (assign_stack_local_1): Use BITS_PER_UNIT alignment
+	when passed -2 as 'align'.
+	(put_var_into_stack): Adjust calls to put_reg_into_stack.
+	When passed a CONCAT, instruct put_reg_into_stack to use
+	a consecutive stack slot for the second part.
+	(put_reg_into_stack): Remove 'promoted_mode' parameter, add
+	'consecutive_p' parameter.  Retrieve the register mode from 'reg'.
+	When consecutive_p is true, instruct assign_stack_local_1 to use
+	BITS_PER_UNIT alignment.
+	(put_addressof_into_stack): Adjust call to put_reg_into_stack.
+
+2004-12-16  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR middle-end/18590
+	* function.c (fixup_var_refs_insns_with_hash): Do not invoke
+	fixup_var_refs_insn on insns marked as deleted.
+
+2004-12-15  Richard Henderson  <rth@redhat.com>
+
+        PR target/19005
+        * config/i386/i386.md (swaphi_1): Swap with swaphi_2, allow with
+        optimize_size.
+        (swapqi_1): Rename from swapqi.  Enable only for no partial reg
+        stall and optimize_size.
+        (swapqi_2): New.
+        (swaphi_1, swaphi_2, swapqi_1): Add athlon_decode.
+        (swapsi, swaphi_1, swaphi_2, swapqi_1, swapdi): Remove modrm override.
+
+2004-12-13  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR middle-end/18730
+	* emit-rtl.c (get_first_nonnote_insn, get_last_nonnote_insn): When
+	the first/last insn is a sequence, return the first/last insn of the
+	sequence.
+
+2004-12-12  Richard Henderson  <rth@redhat.com>
+
+        PR target/18932
+        * config/i386/i386.md (all splits and peepholes): Use flags_reg_operand
+        and compare_operator to propagate the input CC mode to the output.
+        * config/i386/i386.c (flags_reg_operand, compare_operator): New.
+        * config/i386/i386.h (PREDICATE_CODES): Add them.
+        * config/i386/i386-protos.h: Update.
+
+2004-12-10  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>
+
+	PR rtl-optimization/16536
+	Backport from mainline:
+	2004-06-25  Mark Mitchell  <mark@codesourcery.com>
+	* alias.c (get_alias_set): Adjust setting of
+	DECL_POINTER_ALIAS_SET for pointers to aggregates.
+
+2004-12-09  Richard Henderson  <rth@redhat.com>
+
+	PR target/17025
+	* config/i386/i386.md (testqi_1_maybe_si, andqi_2_maybe_si): New.
+	(test_qi_1, andqi_2): Do not promote to simode.
+
+2004-12-07  David Mosberger  <davidm@hpl.hp.com>
+
+	PR target/18443
+	* config/ia64/ia64.c (ia64_assemble_integer): Add support for
+	emitting unaligned pointer-sized integers.
+
+2004-12-05  Richard Henderson  <rth@redhat.com>
+
+	PR target/18841
+	* config/alpha/alpha.md (UNSPECV_SETJMPR_ER): New.
+	(builtin_setjmp_receiver_er_sl_1): Use it.
+	(builtin_setjmp_receiver_er_1): Likewise.
+	(builtin_setjmp_receiver_er, exception_receiver_er): Remove.
+	(builtin_setjmp_receiver): Don't split for explicit relocs until
+	after reload.
+	(exception_receiver): Likewise.
+
+2004-12-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	2003-10-31  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+	Backport from mainline
+	* aclocal.m4 (gcc_AC_FUNC_MMAP_BLACKLIST): Blacklist ultrix*.
+	* configure: Rebuilt.
+
+2004-12-03  Richard Henderson  <rth@redhat.com>
+
+	2004-09-24  Richard Henderson  <rth@redhat.com>
+	PR rtl-opt/17503
+	* regclass.c (subregs_of_mode): Turn into an htab.  Make static.
+	(som_hash, som_eq): New.
+	(init_subregs_of_mode, record_subregs_of_mode): New.
+	(cannot_change_mode_set_regs): Rewrite for htab implementation.
+	(invalid_mode_change_p): Likewise.
+	* combine.c (gen_lowpart_for_combine): Use record_subregs_of_mode.
+	* flow.c (mark_used_regs): Likewise.
+	(life_analysis): Use init_subregs_of_mode.
+	* regs.h (subregs_of_mode): Remove.
+	* rtl.h (init_subregs_of_mode, record_subregs_of_mode): Declare.
+
+2004-12-03  Roger Sayle  <roger@eyesopen.com>
+
+	PR target/9908
+	* config/i386/i386.md (*call_value_1): Correct Intel assembler
+	syntax by using %A1 instead of %*%1.
+
+2004-12-01  Alan Modra  <amodra@bigpond.net.au>
+
+	PR target/12817
+	* config/rs6000/rs6000.c (rs6000_emit_prologue): Use r0 for vrsave.
+
+2004-11-29  Roger Sayle  <roger@eyesopen.com>
+
+	PR rtl-optimization/9771
+	* regclass.c (CALL_REALLY_USED_REGNO_P): New macro to eliminate
+	conditional compilation in init_reg_sets_1.
+	(init_reg_sets_1): Let global_regs[i] take priority over the frame
+	(but not stack) pointer exceptions to regs_invalidated_by_call.
+	(globalize_reg): Globalizing a fixed register may need to update
+	regs_invalidated_by_call.
+
+2004-11-27  Falk Hueffner  <falk@debian.org>
+	    Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR optimization/18577
+	* unroll.c (unroll_loop): Test both REGNO_LAST_UID and
+	REGNO_LAST_NOTE_UID to decide whether a pseudo is local
+	to the loop.
+
+2004-11-27  Alan Modra  <amodra@bigpond.net.au>
+
+	PR target/12769
+	* config/rs6000/rs6000.c (init_cumulative_args): Set call_cookie
+	from rs6000_default_long_calls for libcalls.
+
+2004-11-25  Richard Henderson  <rth@redhat.com>
+
+	PR c++/6764
+	* reload1.c (set_initial_eh_label_offset): New.
+	(set_initial_label_offsets): Use it.
+
+2004-11-22  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR rtl-optimization/14838
+	* emit-rtl.c (get_first_nonnote_insn): Don't assume first insn is a
+	note.
+	(get_last_nonnote_insn): Don't assume last insn is a note.
+
+2004-10-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* doc/install.texi (*-*-solaris2*): Update with info about kernel
+	patches to solve spurious testsuite failures.
+
+2004-10-13  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR target/14454
+	* config/sparc/sparc.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Set to
+	sparc_can_output_mi_thunk.
+	(sparc_output_mi_thunk): Simplify handling of delta offset.  Add
+	handling of vcall offset.
+	(sparc_can_output_mi_thunk): New predicate.
+	* doc/tm.texi (TARGET_ASM_OUTPUT_MI_THUNK): Document VCALL_OFFSET.
+	(TARGET_ASM_OUTPUT_MI_VCALL_THUNK): Delete.
+	(TARGET_ASM_CAN_OUTPUT_MI_THUNK): New target hook.
+
+	* config/sparc/sparc.md (movdi): Remove redundant test.
+
+2004-10-07  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* doc/install.texi (*-*-solaris2*): Fix marker for URL.
+
+2004-10-06  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR target/16007
+	* doc/install.texi (*-*-solaris2*): Mention potential problem
+	with Sun assembler + GNU linker and C++ programs.
+	Document status of binutils 2.15 release.
+
+2004-09-30  Richard Henderson  <rth@redhat.com>
+ 
+	* config/alpha/qrnnd.asm: Mark for noexecstack.
+ 
+2004-09-30  Richard Henderson  <rth@redhat.com>
+  
+	* unwind-dw2.c (_Unwind_GetGR): Honor DWARF_ZERO_REG.
+	* doc/tm.texi (DWARF_ZERO_REG): New.
+  
+	* config/alpha/alpha.c (alpha_sa_mask, alpha_expand_prologue,
+	alpha_expand_epilogue): Revert 2003-09-30 change to store zero.
+	* config/alpha/alpha.h (DWARF_ZERO_REG): New.
+
 2004-09-30  Release Manager
 
 	* GCC 3.3.5 Released.
@@ -19,12 +330,12 @@
 
 2004-09-13  Richard Henderson  <rth@redhat.com>
 
-        PR inline-asm/6806
-        * cselib.c (cselib_invalidate_rtx): Export.  Remove unused args.
-        (cselib_invalidate_rtx_note_stores): New.
-        (cselib_record_sets, cselib_process_insn): Update to match.
-        * cselib.h (cselib_invalidate_rtx): Declare.
-        * reload1.c (reload_cse_simplify): Invalidate asm clobbers.
+	PR inline-asm/6806
+	* cselib.c (cselib_invalidate_rtx): Export.  Remove unused args.
+	(cselib_invalidate_rtx_note_stores): New.
+	(cselib_record_sets, cselib_process_insn): Update to match.
+	* cselib.h (cselib_invalidate_rtx): Declare.
+	* reload1.c (reload_cse_simplify): Invalidate asm clobbers.
 
 2004-08-29  Jonathan Wakely  <redi@gcc.gnu.org>
 
@@ -83,7 +394,7 @@
 2004-07-25  Andreas Jaeger  <aj@suse.de>
 
 	Backport from mainline:
-        * libgcc-std.ver: Add __unorddf2 and __unordsf2 with version 3.3.4.
+	* libgcc-std.ver: Add __unorddf2 and __unordsf2 with version 3.3.4.
 
 2004-07-25  Kaz Kojima  <kkojima@gcc.gnu.org>
 
@@ -155,14 +466,14 @@
 	side-effect of having a length greater or equal to 3.
 
 2004-07-13  Eric Botcazou  <ebotcazou@libertysurf.fr>
-            Lloyd Parkes  <lloyd@must-have-coffee.gen.nz>
+	    Lloyd Parkes  <lloyd@must-have-coffee.gen.nz>
 
 	PR target/15186
 	* config/sparc/sol2-bi.h (LINK_ARCH64_SPEC_BASE): Pass
 	/usr/ucblib/sparcv9 as -R path when -compat-bsd is specified.
 
 2004-07-13  Eric Botcazou  <ebotcazou@libertysurf.fr>
-            Martin Sebor  <sebor@roguewave.com>
+	    Martin Sebor  <sebor@roguewave.com>
 
 	PR target/12602
 	* doc/invoke.texi (SPARC options): Document -threads
@@ -252,18 +563,18 @@
 
 	Backport from mainline:
 	2004-01-19  Richard Henderson  <rth@redhat.com>
-        * alpha.md (UNSPEC_NT_LDA): Renumber.
-        (UNSPEC_CVTLQ, cvtlq): New.
-        (extendsidi2_1): Rename from extendsidi2_nofix; remove f/f.
-        (extendsidi2_fix): Remove.
-        (extendsidi2 splitter): Use cvtlq.
-        (extendsidi2 fp peepholes): Remove.
-        (cvtql): Use SFmode instead of SImode.
-        (fix_trunc?fsi): Update to match.
-        (floatsisf2_ieee, floatsisf2, floatsidf2_ieee, floatsidf2): New.
-        (movsi): Rename from movsi_nofix, remove f alternatives.
-        (movsi_nt_vms): Similarly.
-        (movsi_fix, movsi_nt_vms_fix): Remove.
+	* alpha.md (UNSPEC_NT_LDA): Renumber.
+	(UNSPEC_CVTLQ, cvtlq): New.
+	(extendsidi2_1): Rename from extendsidi2_nofix; remove f/f.
+	(extendsidi2_fix): Remove.
+	(extendsidi2 splitter): Use cvtlq.
+	(extendsidi2 fp peepholes): Remove.
+	(cvtql): Use SFmode instead of SImode.
+	(fix_trunc?fsi): Update to match.
+	(floatsisf2_ieee, floatsisf2, floatsidf2_ieee, floatsidf2): New.
+	(movsi): Rename from movsi_nofix, remove f alternatives.
+	(movsi_nt_vms): Similarly.
+	(movsi_fix, movsi_nt_vms_fix): Remove.
 
 2004-05-26  Hans-Peter Nilsson  <hp@axis.com>
 
Index: gcc/aclocal.m4
===================================================================
RCS file: /cvs/gcc/gcc/gcc/aclocal.m4,v
retrieving revision 1.61.2.4
retrieving revision 1.61.2.5
diff -u -r1.61.2.4 -r1.61.2.5
--- gcc/gcc/aclocal.m4	1 Oct 2003 21:56:34 -0000	1.61.2.4
+++ gcc/gcc/aclocal.m4	4 Dec 2004 01:51:47 -0000	1.61.2.5
@@ -413,7 +413,7 @@
    # read() to the same fd.  The only system known to have a problem here
    # is VMS, where text files have record structure.
    case "$host_os" in
-     vms*) 
+     vms* | ultrix*) 
         gcc_cv_func_mmap_file=no ;;
      *)
         gcc_cv_func_mmap_file=yes;;
Index: gcc/alias.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/alias.c,v
retrieving revision 1.181.2.6
retrieving revision 1.181.2.7
diff -u -r1.181.2.6 -r1.181.2.7
--- gcc/gcc/alias.c	28 May 2004 17:27:27 -0000	1.181.2.6
+++ gcc/gcc/alias.c	10 Dec 2004 17:25:00 -0000	1.181.2.7
@@ -508,6 +508,8 @@
 	      /* If we haven't computed the actual alias set, do it now.  */
 	      if (DECL_POINTER_ALIAS_SET (decl) == -2)
 		{
+		  tree pointed_to_type = TREE_TYPE (TREE_TYPE (decl));
+
 		  /* No two restricted pointers can point at the same thing.
 		     However, a restricted pointer can point at the same thing
 		     as an unrestricted pointer, if that unrestricted pointer
@@ -516,11 +518,22 @@
 		     alias set for the type pointed to by the type of the
 		     decl.  */
 		  HOST_WIDE_INT pointed_to_alias_set
-		    = get_alias_set (TREE_TYPE (TREE_TYPE (decl)));
+		    = get_alias_set (pointed_to_type);
 
 		  if (pointed_to_alias_set == 0)
 		    /* It's not legal to make a subset of alias set zero.  */
-		    ;
+		    DECL_POINTER_ALIAS_SET (decl) = 0;
+		  else if (AGGREGATE_TYPE_P (pointed_to_type))
+		    /* For an aggregate, we must treat the restricted
+		       pointer the same as an ordinary pointer.  If we
+		       were to make the type pointed to by the
+		       restricted pointer a subset of the pointed-to
+		       type, then we would believe that other subsets
+		       of the pointed-to type (such as fields of that
+		       type) do not conflict with the type pointed to
+		       by the restricted pointer.   */
+		    DECL_POINTER_ALIAS_SET (decl)
+		      = pointed_to_alias_set;
 		  else
 		    {
 		      DECL_POINTER_ALIAS_SET (decl) = new_alias_set ();
Index: gcc/c-parse.in
===================================================================
RCS file: /cvs/gcc/gcc/gcc/c-parse.in,v
retrieving revision 1.152.14.1
retrieving revision 1.152.14.2
diff -u -r1.152.14.1 -r1.152.14.2
--- gcc/gcc/c-parse.in	28 Jan 2003 01:54:03 -0000	1.152.14.1
+++ gcc/gcc/c-parse.in	21 Dec 2004 21:51:26 -0000	1.152.14.2
@@ -2177,6 +2177,7 @@
 		  push_label_level ();
 		  compstmt_count++;
 		  $$ = add_stmt (build_stmt (COMPOUND_STMT, last_tree));
+		  last_expr_type = NULL_TREE;
 		}
         ;
 
Index: gcc/combine.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/combine.c,v
retrieving revision 1.325.2.17
retrieving revision 1.325.2.19
diff -u -r1.325.2.17 -r1.325.2.19
--- gcc/gcc/combine.c	25 Jul 2004 18:49:54 -0000	1.325.2.17
+++ gcc/gcc/combine.c	18 Jan 2005 08:39:05 -0000	1.325.2.19
@@ -10138,13 +10138,8 @@
 
   result = gen_lowpart_common (mode, x);
 #ifdef CANNOT_CHANGE_MODE_CLASS
-  if (result != 0
-      && GET_CODE (result) == SUBREG
-      && GET_CODE (SUBREG_REG (result)) == REG
-      && REGNO (SUBREG_REG (result)) >= FIRST_PSEUDO_REGISTER)
-    bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (result))
-				      * MAX_MACHINE_MODE
-				      + GET_MODE (result));
+  if (result != 0 && GET_CODE (result) == SUBREG)
+    record_subregs_of_mode (result);
 #endif
 
   if (result)
@@ -10818,34 +10813,61 @@
 	  break;
 
 	case SUBREG:
-	  /* Check for the case where we are comparing A - C1 with C2,
-	     both constants are smaller than 1/2 the maximum positive
-	     value in MODE, and the comparison is equality or unsigned.
-	     In that case, if A is either zero-extended to MODE or has
-	     sufficient sign bits so that the high-order bit in MODE
-	     is a copy of the sign in the inner mode, we can prove that it is
-	     safe to do the operation in the wider mode.  This simplifies
-	     many range checks.  */
+	  /* Check for the case where we are comparing A - C1 with C2, that is
+
+	       (subreg:MODE (plus (A) (-C1))) op (C2)
+
+	     with C1 a constant, and try to lift the SUBREG, i.e. to do the
+	     comparison in the wider mode.  One of the following two conditions
+	     must be true in order for this to be valid:
+
+	       1. The mode extension results in the same bit pattern being added
+		  on both sides and the comparison is equality or unsigned.  As
+		  C2 has been truncated to fit in MODE, the pattern can only be
+		  all 0s or all 1s.
+
+	       2. The mode extension results in the sign bit being copied on
+		  each side.
+
+	     The difficulty here is that we have predicates for A but not for
+	     (A - C1) so we need to check that C1 is within proper bounds so
+	     as to perturbate A as little as possible.  */
 
 	  if (mode_width <= HOST_BITS_PER_WIDE_INT
 	      && subreg_lowpart_p (op0)
+	      && GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0))) > mode_width
 	      && GET_CODE (SUBREG_REG (op0)) == PLUS
-	      && GET_CODE (XEXP (SUBREG_REG (op0), 1)) == CONST_INT
-	      && INTVAL (XEXP (SUBREG_REG (op0), 1)) < 0
-	      && (-INTVAL (XEXP (SUBREG_REG (op0), 1))
-		  < (HOST_WIDE_INT) (GET_MODE_MASK (mode) / 2))
-	      && (unsigned HOST_WIDE_INT) const_op < GET_MODE_MASK (mode) / 2
-	      && (0 == (nonzero_bits (XEXP (SUBREG_REG (op0), 0),
-				      GET_MODE (SUBREG_REG (op0)))
-			& ~GET_MODE_MASK (mode))
-		  || (num_sign_bit_copies (XEXP (SUBREG_REG (op0), 0),
-					   GET_MODE (SUBREG_REG (op0)))
-		      > (unsigned int)
-			(GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))
-			 - GET_MODE_BITSIZE (mode)))))
+	      && GET_CODE (XEXP (SUBREG_REG (op0), 1)) == CONST_INT)
 	    {
-	      op0 = SUBREG_REG (op0);
-	      continue;
+	      enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));
+	      rtx a = XEXP (SUBREG_REG (op0), 0);
+	      HOST_WIDE_INT c1 = -INTVAL (XEXP (SUBREG_REG (op0), 1));
+
+	      if ((c1 > 0
+	           && (unsigned HOST_WIDE_INT) c1
+		       < (unsigned HOST_WIDE_INT) 1 << (mode_width - 1)
+		   && (equality_comparison_p || unsigned_comparison_p)
+		   /* (A - C1) zero-extends if it is positive and sign-extends
+		      if it is negative, C2 both zero- and sign-extends.  */
+		   && ((0 == (nonzero_bits (a, inner_mode)
+			      & ~GET_MODE_MASK (mode))
+			&& const_op >= 0)
+		       /* (A - C1) sign-extends if it is positive and 1-extends
+			  if it is negative, C2 both sign- and 1-extends.  */
+		       || (num_sign_bit_copies (a, inner_mode)
+			   > (unsigned int) (GET_MODE_BITSIZE (inner_mode)
+					     - mode_width)
+			   && const_op < 0)))
+		  || ((unsigned HOST_WIDE_INT) c1
+		       < (unsigned HOST_WIDE_INT) 1 << (mode_width - 2)
+		      /* (A - C1) always sign-extends, like C2.  */
+		      && num_sign_bit_copies (a, inner_mode)
+			 > (unsigned int) (GET_MODE_BITSIZE (inner_mode)
+					   - mode_width - 1)))
+		{
+		  op0 = SUBREG_REG (op0);
+		  continue;
+	        }
 	    }
 
 	  /* If the inner mode is narrower and we are extracting the low part,
Index: gcc/configure
===================================================================
RCS file: /cvs/gcc/gcc/gcc/configure,v
retrieving revision 1.641.2.23
retrieving revision 1.641.2.24
diff -u -r1.641.2.23 -r1.641.2.24
--- gcc/gcc/configure	1 Apr 2004 16:55:23 -0000	1.641.2.23
+++ gcc/gcc/configure	4 Dec 2004 01:51:43 -0000	1.641.2.24
@@ -2399,7 +2399,7 @@
 fi
 
 # Find some useful tools
-for ac_prog in gawk mawk nawk awk
+for ac_prog in mawk gawk nawk awk
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
@@ -3947,7 +3947,7 @@
    # read() to the same fd.  The only system known to have a problem here
    # is VMS, where text files have record structure.
    case "$host_os" in
-     vms*) 
+     vms* | ultrix*) 
         gcc_cv_func_mmap_file=no ;;
      *)
         gcc_cv_func_mmap_file=yes;;
@@ -8120,7 +8120,7 @@
 echo "$ac_t""$gcc_cv_ld_eh_frame_hdr" 1>&6
 
 echo $ac_n "checking linker --as-needed support""... $ac_c" 1>&6
-echo "configure:8250: checking linker --as-needed support" >&5
+echo "configure:8124: checking linker --as-needed support" >&5
 gcc_cv_ld_as_needed=no
 if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then
   if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge 16 -o "$gcc_cv_gld_major_version" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then
@@ -8144,7 +8144,7 @@
 case "$target" in
   mips*-*-*)
     echo $ac_n "checking whether libgloss uses STARTUP directives consistently""... $ac_c" 1>&6
-echo "configure:8127: checking whether libgloss uses STARTUP directives consistently" >&5
+echo "configure:8148: checking whether libgloss uses STARTUP directives consistently" >&5
     gcc_cv_mips_libgloss_startup=no
     gcc_cv_libgloss_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/libgloss
     if test "x$exec_prefix" = xNONE; then
@@ -8349,7 +8349,7 @@
 
 
 echo $ac_n "checking whether to enable maintainer-specific portions of Makefiles""... $ac_c" 1>&6
-echo "configure:8332: checking whether to enable maintainer-specific portions of Makefiles" >&5
+echo "configure:8353: checking whether to enable maintainer-specific portions of Makefiles" >&5
     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
 if test "${enable_maintainer_mode+set}" = set; then
   enableval="$enable_maintainer_mode"
Index: gcc/emit-rtl.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/emit-rtl.c,v
retrieving revision 1.303.2.5
retrieving revision 1.303.2.7
diff -u -r1.303.2.5 -r1.303.2.7
--- gcc/gcc/emit-rtl.c	18 Jun 2004 17:08:48 -0000	1.303.2.5
+++ gcc/gcc/emit-rtl.c	14 Dec 2004 04:06:08 -0000	1.303.2.7
@@ -2890,11 +2890,19 @@
 {
   rtx insn = first_insn;
 
-  while (insn)
+  if (insn)
     {
-      insn = next_insn (insn);
-      if (insn == 0 || GET_CODE (insn) != NOTE)
-	break;
+      if (NOTE_P (insn))
+	for (insn = next_insn (insn);
+	     insn && NOTE_P (insn);
+	     insn = next_insn (insn))
+	  continue;
+      else
+	{
+	  if (GET_CODE (insn) == INSN
+	      && GET_CODE (PATTERN (insn)) == SEQUENCE)
+	    insn = XVECEXP (PATTERN (insn), 0, 0);
+	}
     }
 
   return insn;
@@ -2908,11 +2916,20 @@
 {
   rtx insn = last_insn;
 
-  while (insn)
+  if (insn)
     {
-      insn = previous_insn (insn);
-      if (insn == 0 || GET_CODE (insn) != NOTE)
-	break;
+      if (NOTE_P (insn))
+	for (insn = previous_insn (insn);
+	     insn && NOTE_P (insn);
+	     insn = previous_insn (insn))
+	  continue;
+      else
+	{
+	  if (GET_CODE (insn) == INSN
+	      && GET_CODE (PATTERN (insn)) == SEQUENCE)
+	    insn = XVECEXP (PATTERN (insn), 0,
+			    XVECLEN (PATTERN (insn), 0) - 1);
+	}
     }
 
   return insn;
Index: gcc/expr.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/expr.c,v
retrieving revision 1.498.2.31
retrieving revision 1.498.2.32
diff -u -r1.498.2.31 -r1.498.2.32
--- gcc/gcc/expr.c	16 May 2004 20:27:15 -0000	1.498.2.31
+++ gcc/gcc/expr.c	20 Dec 2004 02:43:00 -0000	1.498.2.32
@@ -8462,9 +8462,14 @@
       /* At this point, a MEM target is no longer useful; we will get better
 	 code without it.  */
 
-      if (GET_CODE (target) == MEM)
+      if (! REG_P (target))
 	target = gen_reg_rtx (mode);
 
+      /* We generate better code and avoid problems with op1 mentioning
+	 target by forcing op1 into a pseudo if it isn't a constant.  */
+      if (! CONSTANT_P (op1))
+	op1 = force_reg (mode, op1);
+
       if (target != op0)
 	emit_move_insn (target, op0);
 
Index: gcc/flow.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/flow.c,v
retrieving revision 1.541.2.6
retrieving revision 1.541.2.7
diff -u -r1.541.2.6 -r1.541.2.7
--- gcc/gcc/flow.c	5 Mar 2004 17:55:50 -0000	1.541.2.6
+++ gcc/gcc/flow.c	4 Dec 2004 00:36:35 -0000	1.541.2.7
@@ -431,9 +431,8 @@
   SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);
 #endif
 
-
 #ifdef CANNOT_CHANGE_MODE_CLASS
-  bitmap_initialize (&subregs_of_mode, 1);
+  init_subregs_of_mode ();
 #endif
 
   if (! optimize)
@@ -3851,11 +3850,7 @@
 
     case SUBREG:
 #ifdef CANNOT_CHANGE_MODE_CLASS
-      if (GET_CODE (SUBREG_REG (x)) == REG
-	  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)
-	bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (x))
-					  * MAX_MACHINE_MODE
-					  + GET_MODE (x));
+      record_subregs_of_mode (x);
 #endif
 
       /* While we're here, optimize this case.  */
@@ -3900,12 +3895,8 @@
 	       || GET_CODE (testreg) == SUBREG)
 	  {
 #ifdef CANNOT_CHANGE_MODE_CLASS
-	    if (GET_CODE (testreg) == SUBREG
-		&& GET_CODE (SUBREG_REG (testreg)) == REG
-		&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER)
-	      bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (testreg))
-						* MAX_MACHINE_MODE
-						+ GET_MODE (testreg));
+	    if (GET_CODE (testreg) == SUBREG)
+	      record_subregs_of_mode (testreg);
 #endif
 
 	    /* Modifying a single register in an alternate mode
Index: gcc/function.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/function.c,v
retrieving revision 1.389.2.16
retrieving revision 1.389.2.18
diff -u -r1.389.2.16 -r1.389.2.18
--- gcc/gcc/function.c	16 May 2004 20:27:16 -0000	1.389.2.16
+++ gcc/gcc/function.c	16 Dec 2004 14:04:34 -0000	1.389.2.18
@@ -226,9 +226,8 @@
 					 int, struct function *));
 static struct temp_slot *find_temp_slot_from_address  PARAMS ((rtx));
 static void put_reg_into_stack	PARAMS ((struct function *, rtx, tree,
-					 enum machine_mode, enum machine_mode,
-					 int, unsigned int, int,
-					 htab_t));
+					 enum machine_mode, unsigned int,
+					 int, int, int, htab_t));
 static void schedule_fixup_var_refs PARAMS ((struct function *, rtx, tree,
 					     enum machine_mode,
 					     htab_t));
@@ -508,6 +507,7 @@
    ALIGN controls the amount of alignment for the address of the slot:
    0 means according to MODE,
    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,
+   -2 means use BITS_PER_UNIT,
    positive specifies alignment boundary in bits.
 
    We do not round to stack_boundary here.
@@ -548,6 +548,8 @@
       alignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;
       size = CEIL_ROUND (size, alignment);
     }
+  else if (align == -2)
+    alignment = 1; /* BITS_PER_UNIT / BITS_PER_UNIT */
   else
     alignment = align / BITS_PER_UNIT;
 
@@ -1342,9 +1344,9 @@
   enum machine_mode promoted_mode, decl_mode;
   struct function *function = 0;
   tree context;
-  int can_use_addressof;
-  int volatilep = TREE_CODE (decl) != SAVE_EXPR && TREE_THIS_VOLATILE (decl);
-  int usedp = (TREE_USED (decl)
+  int can_use_addressof_p;
+  int volatile_p = TREE_CODE (decl) != SAVE_EXPR && TREE_THIS_VOLATILE (decl);
+  int used_p = (TREE_USED (decl)
 	       || (TREE_CODE (decl) != SAVE_EXPR && DECL_INITIAL (decl) != 0));
 
   context = decl_function_context (decl);
@@ -1391,7 +1393,7 @@
   /* If this variable lives in the current function and we don't need to put it
      in the stack for the sake of setjmp or the non-locality, try to keep it in
      a register until we know we actually need the address.  */
-  can_use_addressof
+  can_use_addressof_p
     = (function == 0
        && ! (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl))
        && optimize > 0
@@ -1404,7 +1406,8 @@
 
   /* If we can't use ADDRESSOF, make sure we see through one we already
      generated.  */
-  if (! can_use_addressof && GET_CODE (reg) == MEM
+  if (! can_use_addressof_p
+      && GET_CODE (reg) == MEM
       && GET_CODE (XEXP (reg, 0)) == ADDRESSOF)
     reg = XEXP (XEXP (reg, 0), 0);
 
@@ -1412,11 +1415,11 @@
 
   if (GET_CODE (reg) == REG)
     {
-      if (can_use_addressof)
+      if (can_use_addressof_p)
 	gen_mem_addressof (reg, decl, rescan);
       else
-	put_reg_into_stack (function, reg, TREE_TYPE (decl), promoted_mode,
-			    decl_mode, volatilep, 0, usedp, 0);
+	put_reg_into_stack (function, reg, TREE_TYPE (decl), decl_mode,
+			    0, volatile_p, used_p, 0, 0);
     }
   else if (GET_CODE (reg) == CONCAT)
     {
@@ -1432,14 +1435,14 @@
 #ifdef FRAME_GROWS_DOWNWARD
       /* Since part 0 should have a lower address, do it second.  */
       put_reg_into_stack (function, hipart, part_type, part_mode,
-			  part_mode, volatilep, 0, 0, 0);
+			  0, volatile_p, 0, 0, 0);
       put_reg_into_stack (function, lopart, part_type, part_mode,
-			  part_mode, volatilep, 0, 0, 0);
+			  0, volatile_p, 0, 1, 0);
 #else
       put_reg_into_stack (function, lopart, part_type, part_mode,
-			  part_mode, volatilep, 0, 0, 0);
+			  0, volatile_p, 0, 0, 0);
       put_reg_into_stack (function, hipart, part_type, part_mode,
-			  part_mode, volatilep, 0, 0, 0);
+			  0, volatile_p, 0, 1, 0);
 #endif
 
       /* Change the CONCAT into a combined MEM for both parts.  */
@@ -1460,7 +1463,7 @@
       /* Prevent sharing of rtl that might lose.  */
       if (GET_CODE (XEXP (reg, 0)) == PLUS)
 	XEXP (reg, 0) = copy_rtx (XEXP (reg, 0));
-      if (usedp && rescan)
+      if (used_p && rescan)
 	{
 	  schedule_fixup_var_refs (function, reg, TREE_TYPE (decl),
 				   promoted_mode, 0);
@@ -1474,26 +1477,29 @@
 
 /* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG
    into the stack frame of FUNCTION (0 means the current function).
+   TYPE is the user-level data type of the value hold in the register.
    DECL_MODE is the machine mode of the user-level data type.
-   PROMOTED_MODE is the machine mode of the register.
-   VOLATILE_P is nonzero if this is for a "volatile" decl.
-   USED_P is nonzero if this reg might have already been used in an insn.  */
+   ORIGINAL_REGNO must be set if the real regno is not visible in REG.
+   VOLATILE_P is true if this is for a "volatile" decl.
+   USED_P is true if this reg might have already been used in an insn.
+   CONSECUTIVE_P is true if the stack slot assigned to reg must be
+   consecutive with the previous stack slot.  */
 
 static void
-put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,
-		    original_regno, used_p, ht)
+put_reg_into_stack (function, reg, type, decl_mode, original_regno,
+		    volatile_p, used_p, consecutive_p, ht)
      struct function *function;
      rtx reg;
      tree type;
-     enum machine_mode promoted_mode, decl_mode;
-     int volatile_p;
+     enum machine_mode decl_mode;
      unsigned int original_regno;
-     int used_p;
+     int volatile_p, used_p, consecutive_p;
      htab_t ht;
 {
   struct function *func = function ? function : cfun;
-  rtx new = 0;
+  enum machine_mode mode = GET_MODE (reg);
   unsigned int regno = original_regno;
+  rtx new = 0;
 
   if (regno == 0)
     regno = REGNO (reg);
@@ -1506,7 +1512,8 @@
     }
 
   if (new == 0)
-    new = assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode), 0, func);
+    new = assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode),
+				consecutive_p ? -2 : 0, func);
 
   PUT_CODE (reg, MEM);
   PUT_MODE (reg, decl_mode);
@@ -1528,7 +1535,7 @@
     }
 
   if (used_p)
-    schedule_fixup_var_refs (function, reg, type, promoted_mode, ht);
+    schedule_fixup_var_refs (function, reg, type, mode, ht);
 }
 
 /* Make sure that all refs to the variable, previously made
@@ -1716,7 +1723,7 @@
   tmp.key = var;
   ime = (struct insns_for_mem_entry *) htab_find (ht, &tmp);
   for (insn_list = ime->insns; insn_list != 0; insn_list = XEXP (insn_list, 1))
-    if (INSN_P (XEXP (insn_list, 0)))
+    if (INSN_P (XEXP (insn_list, 0)) && !INSN_DELETED_P (XEXP (insn_list, 0)))
       fixup_var_refs_insn (XEXP (insn_list, 0), var, promoted_mode,
 			   unsignedp, 1, may_share);
 }
@@ -3025,8 +3032,8 @@
       used_p = 1;
     }
 
-  put_reg_into_stack (0, reg, type, GET_MODE (reg), GET_MODE (reg),
-		      volatile_p, ADDRESSOF_REGNO (r), used_p, ht);
+  put_reg_into_stack (0, reg, type, GET_MODE (reg), ADDRESSOF_REGNO (r),
+		      volatile_p, used_p, 0, ht);
 }
 
 /* List of replacements made below in purge_addressof_1 when creating
Index: gcc/gccbug.in
===================================================================
RCS file: /cvs/gcc/gcc/gcc/gccbug.in,v
retrieving revision 1.15.34.1
retrieving revision 1.15.34.2
diff -u -r1.15.34.1 -r1.15.34.2
--- gcc/gcc/gccbug.in	2 Jan 2003 05:22:37 -0000	1.15.34.1
+++ gcc/gcc/gccbug.in	21 Jan 2005 10:08:47 -0000	1.15.34.2
@@ -198,7 +198,7 @@
 done
 
 # spam does not need to be listed here
-CATEGORIES="ada bootstrap c++ c debug driver fortran inline-asm java libf2c libgcj libobjc libstdc++ middle-end objc optimization other preprocessor target web"
+CATEGORIES="ada bootstrap c++ c debug driver fortran inline-asm java libf2c libgcj libobjc libstdc++ middle-end objc other preprocessor rtl-optimization target tree-optimization web"
 
 case "$FORMAT" in
   lisp) echo "$CATEGORIES" | \
Index: gcc/regclass.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/regclass.c,v
retrieving revision 1.160.4.5
retrieving revision 1.160.4.8
diff -u -r1.160.4.5 -r1.160.4.8
--- gcc/gcc/regclass.c	3 Mar 2003 11:00:15 -0000	1.160.4.5
+++ gcc/gcc/regclass.c	4 Dec 2004 00:36:37 -0000	1.160.4.8
@@ -41,6 +41,7 @@
 #include "toplev.h"
 #include "output.h"
 #include "ggc.h"
+#include "hashtab.h"
 
 #ifndef REGISTER_MOVE_COST
 #define REGISTER_MOVE_COST(m, x, y) 2
@@ -105,6 +106,13 @@
 char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;
 #endif
 
+#ifdef CALL_REALLY_USED_REGISTERS
+#define CALL_REALLY_USED_REGNO_P(X)  call_really_used_regs[X]
+#else
+#define CALL_REALLY_USED_REGNO_P(X)  call_used_regs[X]
+#endif
+
+
 /* Indexed by hard register number, contains 1 for registers that are
    fixed use or call used registers that cannot hold quantities across
    calls even if we are willing to save and restore them.  call fixed
@@ -228,12 +236,6 @@
 
 #endif /* FORBIDDEN_INC_DEC_CLASSES */
 
-#ifdef CANNOT_CHANGE_MODE_CLASS
-/* All registers that have been subreged.  Indexed by regno * MAX_MACHINE_MODE
-   + mode.  */
-bitmap_head subregs_of_mode;
-#endif
-
 /* Sample MEM values for use by memory_move_secondary_cost.  */
 
 static GTY(()) rtx top_of_stack[MAX_MACHINE_MODE];
@@ -447,7 +449,11 @@
 	 If we are generating PIC code, the PIC offset table register is
 	 preserved across calls, though the target can override that.  */
 
-      if (i == STACK_POINTER_REGNUM || i == FRAME_POINTER_REGNUM)
+      if (i == STACK_POINTER_REGNUM)
+	;
+      else if (global_regs[i])
+	SET_HARD_REG_BIT (regs_invalidated_by_call, i);
+      else if (i == FRAME_POINTER_REGNUM)
 	;
 #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM
       else if (i == HARD_FRAME_POINTER_REGNUM)
@@ -461,13 +467,7 @@
       else if (i == PIC_OFFSET_TABLE_REGNUM && fixed_regs[i])
 	;
 #endif
-      else if (0
-#ifdef CALL_REALLY_USED_REGISTERS
-	       || call_really_used_regs[i]
-#else
-	       || call_used_regs[i]
-#endif
-	       || global_regs[i])
+      else if (CALL_REALLY_USED_REGNO_P (i))
 	SET_HARD_REG_BIT (regs_invalidated_by_call, i);
     }
 
@@ -792,6 +792,12 @@
 
   global_regs[i] = 1;
 
+  /* If we're globalizing the frame pointer, we need to set the
+     appropriate regs_invalidated_by_call bit, even if it's already
+     set in fixed_regs.  */
+  if (i != STACK_POINTER_REGNUM)
+    SET_HARD_REG_BIT (regs_invalidated_by_call, i);
+
   /* If already fixed, nothing else to do.  */
   if (fixed_regs[i])
     return;
@@ -802,7 +808,6 @@
   SET_HARD_REG_BIT (fixed_reg_set, i);
   SET_HARD_REG_BIT (call_used_reg_set, i);
   SET_HARD_REG_BIT (call_fixed_reg_set, i);
-  SET_HARD_REG_BIT (regs_invalidated_by_call, i);
 }
 
 /* Now the data and code for the `regclass' pass, which happens
@@ -2415,9 +2420,15 @@
 
 	if (regno >= min_regno)
 	  {
+	    /* While the following 3 lines means that the inequality
+	         REGNO_LAST_UID (regno) <= REGNO_LAST_NOTE_UID (regno)
+	       is true at the end of the scanning, it may be subsequently
+	       invalidated (e.g. in load_mems) so it should not be relied
+	       upon.  */
 	    REGNO_LAST_NOTE_UID (regno) = INSN_UID (insn);
 	    if (!note_flag)
 	      REGNO_LAST_UID (regno) = INSN_UID (insn);
+
 	    if (REGNO_FIRST_UID (regno) == 0)
 	      REGNO_FIRST_UID (regno) = INSN_UID (insn);
 	    /* If we are called by reg_scan_update() (indicated by min_regno
@@ -2614,6 +2625,77 @@
 }
 
 #ifdef CANNOT_CHANGE_MODE_CLASS
+
+struct subregs_of_mode_node
+{
+  unsigned int block;
+  unsigned char modes[MAX_MACHINE_MODE];
+};
+
+static htab_t subregs_of_mode;
+
+static hashval_t som_hash PARAMS ((const void *));
+static int som_eq PARAMS ((const void *, const void *));
+
+static hashval_t
+som_hash (x)
+     const void *x;
+{
+  const struct subregs_of_mode_node *a = x;
+  return a->block;
+}
+
+static int
+som_eq (x, y)
+     const void *x;
+     const void *y;
+{
+  const struct subregs_of_mode_node *a = x;
+  const struct subregs_of_mode_node *b = y;
+  return a->block == b->block;
+}
+
+void
+init_subregs_of_mode ()
+{
+  if (subregs_of_mode)
+    htab_empty (subregs_of_mode);
+  else
+    subregs_of_mode = htab_create (100, som_hash, som_eq, free);
+}
+
+void
+record_subregs_of_mode (subreg)
+     rtx subreg;
+{
+  struct subregs_of_mode_node dummy, *node;
+  enum machine_mode mode;
+  unsigned int regno;
+  void **slot;
+
+  if (!REG_P (SUBREG_REG (subreg)))
+    return;
+
+  regno = REGNO (SUBREG_REG (subreg));
+  mode = GET_MODE (subreg);
+
+  if (regno < FIRST_PSEUDO_REGISTER)
+    return;
+
+  dummy.block = regno & -8;
+  slot = htab_find_slot_with_hash (subregs_of_mode, &dummy,
+				   dummy.block, INSERT);
+  node = *slot;
+  if (node == NULL)
+    {
+      node = xcalloc (1, sizeof (*node));
+      node->block = regno & -8;
+      *slot = node;
+    }
+
+  node->modes[mode] |= 1 << (regno & 7);
+}
+
 /* Set bits in *USED which correspond to registers which can't change
    their mode from FROM to any mode in which REGNO was encountered.  */
 
@@ -2623,42 +2705,50 @@
      enum machine_mode from;
      unsigned int regno;
 {
+  struct subregs_of_mode_node dummy, *node;
   enum machine_mode to;
-  int n, i;
-  int start = regno * MAX_MACHINE_MODE;
+  unsigned char mask;
+  unsigned int i;
 
-  EXECUTE_IF_SET_IN_BITMAP (&subregs_of_mode, start, n,
-    if (n >= MAX_MACHINE_MODE + start)
-      return;
-    to = n - start;
-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-      if (! TEST_HARD_REG_BIT (*used, i)
-	  && REG_CANNOT_CHANGE_MODE_P (i, from, to))
-	SET_HARD_REG_BIT (*used, i);
-  );
+  dummy.block = regno & -8;
+  node = htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);
+  if (node == NULL)
+    return;
+
+  mask = 1 << (regno & 7);
+  for (to = VOIDmode; to < NUM_MACHINE_MODES; to++)
+    if (node->modes[to] & mask)
+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+	if (!TEST_HARD_REG_BIT (*used, i)
+	    && REG_CANNOT_CHANGE_MODE_P (i, from, to))
+	  SET_HARD_REG_BIT (*used, i);
 }
 
 /* Return 1 if REGNO has had an invalid mode change in CLASS from FROM
    mode.  */
 
 bool
-invalid_mode_change_p (regno, class, from_mode)
+invalid_mode_change_p (regno, class, from)
      unsigned int regno;
-      enum reg_class class;
-     enum machine_mode from_mode;
+     enum reg_class class;
+     enum machine_mode from;
 {
-  enum machine_mode to_mode;
-  int n;
-  int start = regno * MAX_MACHINE_MODE;
-
-  EXECUTE_IF_SET_IN_BITMAP (&subregs_of_mode, start, n,
-    if (n >= MAX_MACHINE_MODE + start)
-      return 0;
-    to_mode = n - start;
-    if (CANNOT_CHANGE_MODE_CLASS (from_mode, to_mode, class))
-      return 1;
-  );
-  return 0;
+  struct subregs_of_mode_node dummy, *node;
+  enum machine_mode to;
+  unsigned char mask;
+
+  dummy.block = regno & -8;
+  node = htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);
+  if (node == NULL)
+    return false;
+
+  mask = 1 << (regno & 7);
+  for (to = VOIDmode; to < NUM_MACHINE_MODES; to++)
+    if (node->modes[to] & mask)
+      if (CANNOT_CHANGE_MODE_CLASS (from, to, class))
+	return true;
+
+  return false;
 }
 #endif /* CANNOT_CHANGE_MODE_CLASS */
 
Index: gcc/regs.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/regs.h,v
retrieving revision 1.26.4.1
retrieving revision 1.26.4.3
diff -u -r1.26.4.1 -r1.26.4.3
--- gcc/gcc/regs.h	3 Mar 2003 11:00:15 -0000	1.26.4.1
+++ gcc/gcc/regs.h	4 Dec 2004 00:36:38 -0000	1.26.4.3
@@ -49,6 +49,9 @@
   int first_uid;		/* UID of first insn to use (REG n) */
   int last_uid;			/* UID of last insn to use (REG n) */
   int last_note_uid;		/* UID of last note to use (REG n) */
+				/* See the comment in reg_scan_mark_refs on
+				   the relationship between last_uid and
+				   last_note_uid.  */
 
 				/* fields set by reg_scan & flow_analysis */
   int sets;			/* # of times (REG n) is set */
@@ -66,8 +69,6 @@
 
 extern varray_type reg_n_info;
 
-extern bitmap_head subregs_of_mode;
-
 /* Indexed by n, gives number of times (REG n) is used or set.  */
 
 #define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)
Index: gcc/reload1.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/reload1.c,v
retrieving revision 1.366.2.11
retrieving revision 1.366.2.12
diff -u -r1.366.2.11 -r1.366.2.12
--- gcc/gcc/reload1.c	13 Sep 2004 08:54:35 -0000	1.366.2.11
+++ gcc/gcc/reload1.c	26 Nov 2004 05:08:45 -0000	1.366.2.12
@@ -3389,6 +3389,16 @@
   num_not_at_initial_offset = 0;
 }
 
+/* Subroutine of set_initial_label_offsets called via for_each_eh_label.  */
+
+static void set_initial_eh_label_offset PARAMS ((rtx));
+static void
+set_initial_eh_label_offset (label)
+     rtx label;
+{
+  set_label_offsets (label, NULL_RTX, 1);
+}
+
 /* Initialize the known label offsets.
    Set a known offset for each forced label to be at the initial offset
    of each elimination.  We do this because we assume that all
@@ -3405,6 +3415,8 @@
   for (x = forced_labels; x; x = XEXP (x, 1))
     if (XEXP (x, 0))
       set_label_offsets (XEXP (x, 0), NULL_RTX, 1);
+
+  for_each_eh_label (set_initial_eh_label_offset);
 }
 
 /* Set all elimination offsets to the known values for the code label given
Index: gcc/rtl.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/rtl.h,v
retrieving revision 1.375.2.8
retrieving revision 1.375.2.9
diff -u -r1.375.2.8 -r1.375.2.9
--- gcc/gcc/rtl.h	24 Apr 2004 19:40:45 -0000	1.375.2.8
+++ gcc/gcc/rtl.h	4 Dec 2004 00:36:38 -0000	1.375.2.9
@@ -2120,6 +2120,8 @@
 extern void reg_scan			PARAMS ((rtx, unsigned int, int));
 extern void reg_scan_update		PARAMS ((rtx, rtx, unsigned int));
 extern void fix_register		PARAMS ((const char *, int, int));
+extern void init_subregs_of_mode	PARAMS ((void));
+extern void record_subregs_of_mode	PARAMS ((rtx));
 #ifdef HARD_CONST
 extern void cannot_change_mode_set_regs PARAMS ((HARD_REG_SET *,
 						 enum machine_mode,
Index: gcc/tree-inline.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/tree-inline.c,v
retrieving revision 1.38.2.12
retrieving revision 1.38.2.13
diff -u -r1.38.2.12 -r1.38.2.13
--- gcc/gcc/tree-inline.c	12 Mar 2004 22:43:29 -0000	1.38.2.12
+++ gcc/gcc/tree-inline.c	21 Jan 2005 10:02:12 -0000	1.38.2.13
@@ -1173,7 +1173,8 @@
   if (!inlinable_function_p (fn, id))
     {
       if (warn_inline && DECL_INLINE (fn) && !DID_INLINE_FUNC (fn)
-	  && !DECL_IN_SYSTEM_HEADER (fn))
+	  && !DECL_IN_SYSTEM_HEADER (fn)
+	  && !lookup_attribute ("noinline", DECL_ATTRIBUTES (fn)))
 	{
 	  warning_with_decl (fn, "inlining failed in call to `%s'");
 	  warning ("called from here");
Index: gcc/unroll.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/Attic/unroll.c,v
retrieving revision 1.184.2.9
retrieving revision 1.184.2.10
diff -u -r1.184.2.9 -r1.184.2.10
--- gcc/gcc/unroll.c	17 May 2004 21:05:48 -0000	1.184.2.9
+++ gcc/gcc/unroll.c	27 Nov 2004 16:59:15 -0000	1.184.2.10
@@ -794,6 +794,10 @@
       for (r = FIRST_PSEUDO_REGISTER; r < max_reg_before_loop; ++r)
 	if (REGNO_FIRST_UID (r) > 0 && REGNO_FIRST_UID (r) < max_uid_for_loop
 	    && REGNO_FIRST_LUID (r) >= copy_start_luid
+	    /* See the comment in reg_scan_mark_refs on the relationship between
+	       last_uid and last_note_uid.  */
+	    && REGNO_LAST_UID (r) > 0 && REGNO_LAST_UID (r) < max_uid_for_loop
+	    && REGNO_LAST_LUID (r) <= copy_end_luid
 	    && REGNO_LAST_NOTE_UID (r) > 0 && REGNO_LAST_NOTE_UID (r) < max_uid_for_loop
 	    && REGNO_LAST_NOTE_LUID (r) <= copy_end_luid)
 	  {
Index: gcc/unwind-dw2.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/unwind-dw2.c,v
retrieving revision 1.22.2.9
retrieving revision 1.22.2.11
diff -u -r1.22.2.9 -r1.22.2.11
--- gcc/gcc/unwind-dw2.c	8 May 2004 21:52:42 -0000	1.22.2.9
+++ gcc/gcc/unwind-dw2.c	29 Jan 2005 11:54:24 -0000	1.22.2.11
@@ -1,5 +1,5 @@
 /* DWARF2 exception handling and frame unwind runtime interface routines.
-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
    Free Software Foundation, Inc.
 
    This file is part of GCC.
@@ -165,6 +165,11 @@
 inline _Unwind_Word
 _Unwind_GetGR (struct _Unwind_Context *context, int index)
 {
+#ifdef DWARF_ZERO_REG
+  if (index == DWARF_ZERO_REG)
+    return 0;
+#endif
+
   /* This will segfault if the register hasn't been saved.  */
   return * (_Unwind_Word *) context->reg[index];
 }
@@ -604,6 +609,10 @@
 	case DW_OP_mul:
 	case DW_OP_or:
 	case DW_OP_plus:
+	case DW_OP_shl:
+	case DW_OP_shr:
+	case DW_OP_shra:
+	case DW_OP_xor:
 	case DW_OP_le:
 	case DW_OP_ge:
 	case DW_OP_eq:
Index: gcc/config/freebsd-spec.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/freebsd-spec.h,v
retrieving revision 1.2.4.1
retrieving revision 1.2.4.2
diff -u -r1.2.4.1 -r1.2.4.2
--- gcc/gcc/config/freebsd-spec.h	12 Mar 2003 02:38:01 -0000	1.2.4.1
+++ gcc/gcc/config/freebsd-spec.h	14 Jan 2005 02:06:26 -0000	1.2.4.2
@@ -130,13 +130,7 @@
     %{pg:  -lc_p}							\
   }"
 #else
-#if FBSD_MAJOR >= 5
-#define FBSD_LIB_SPEC "							\
-  %{!shared:								\
-    %{!pg: %{pthread:-lc_r} -lc}					\
-    %{pg:  %{pthread:-lc_r_p} -lc_p}					\
-  }"
-#else
+#if FBSD_MAJOR < 5
 #define FBSD_LIB_SPEC "							\
   %{!shared:								\
     %{!pg:								\
@@ -146,5 +140,11 @@
       %{!pthread:-lc_p}							\
       %{pthread:-lc_r_p}}						\
   }"
+#else
+#define FBSD_LIB_SPEC "							\
+  %{!shared:								\
+    %{!pg: %{pthread:-lpthread} -lc}					\
+    %{pg:  %{pthread:-lpthread_p} -lc_p}				\
+  }"
 #endif
 #endif
Index: gcc/config/alpha/alpha.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/alpha/alpha.c,v
retrieving revision 1.282.4.11
retrieving revision 1.282.4.12
diff -u -r1.282.4.11 -r1.282.4.12
--- gcc/gcc/config/alpha/alpha.c	8 Mar 2004 03:21:46 -0000	1.282.4.11
+++ gcc/gcc/config/alpha/alpha.c	30 Sep 2004 19:36:26 -0000	1.282.4.12
@@ -6766,11 +6766,6 @@
 	    break;
 	  imask |= 1L << regno;
 	}
-
-      /* Glibc likes to use $31 as an unwind stopper for crt0.  To
-	 avoid hackery in unwind-dw2.c, we need to actively store a
-	 zero in the prologue of _Unwind_RaiseException et al.  */
-      imask |= 1UL << 31;
     }
 
   /* If any register spilled, then spill the return address also.  */
@@ -7236,24 +7231,6 @@
 	    reg_offset += 8;
 	  }
 
-      /* Store a zero if requested for unwinding.  */
-      if (imask & (1UL << 31))
- 	{
- 	  rtx insn, t;
- 
- 	  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));
- 	  set_mem_alias_set (mem, alpha_sr_alias_set);
- 	  insn = emit_move_insn (mem, const0_rtx);
- 
- 	  RTX_FRAME_RELATED_P (insn) = 1;
- 	  t = gen_rtx_REG (Pmode, 31);
- 	  t = gen_rtx_SET (VOIDmode, mem, t);
- 	  t = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, t, REG_NOTES (insn));
- 	  REG_NOTES (insn) = t;
- 
- 	  reg_offset += 8;
- 	}
- 
       for (i = 0; i < 31; i++)
 	if (fmask & (1L << i))
 	  {
@@ -7674,9 +7651,6 @@
 	    reg_offset += 8;
 	  }
 
-      if (imask & (1UL << 31))
-	reg_offset += 8;
-
       for (i = 0; i < 31; ++i)
 	if (fmask & (1L << i))
 	  {
Index: gcc/config/alpha/alpha.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/alpha/alpha.h,v
retrieving revision 1.185.4.6
retrieving revision 1.185.4.7
diff -u -r1.185.4.6 -r1.185.4.7
--- gcc/gcc/config/alpha/alpha.h	27 Aug 2004 00:01:15 -0000	1.185.4.6
+++ gcc/gcc/config/alpha/alpha.h	30 Sep 2004 19:36:28 -0000	1.185.4.7
@@ -1299,6 +1299,7 @@
 #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)
 #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (26)
 #define DWARF_ALT_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (64)
+#define DWARF_ZERO_REG 31
 
 /* Describe how we implement __builtin_eh_return.  */
 #define EH_RETURN_DATA_REGNO(N)	((N) < 4 ? (N) + 16 : INVALID_REGNUM)
Index: gcc/config/alpha/alpha.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/alpha/alpha.md,v
retrieving revision 1.199.4.6
retrieving revision 1.199.4.7
diff -u -r1.199.4.6 -r1.199.4.7
--- gcc/gcc/config/alpha/alpha.md	28 May 2004 00:02:03 -0000	1.199.4.6
+++ gcc/gcc/config/alpha/alpha.md	5 Dec 2004 19:58:42 -0000	1.199.4.7
@@ -80,6 +80,7 @@
    (UNSPECV_PLDGP2	11)	; prologue ldgp
    (UNSPECV_SET_TP	12)
    (UNSPECV_RPCC	13)
+   (UNSPECV_SETJMPR_ER	14)	; builtin_setjmp_receiver fragment
   ])
 
 ;; Where necessary, the suffixes _le and _be are used to distinguish between
@@ -6764,70 +6765,44 @@
   "jmp $31,(%0),0"
   [(set_attr "type" "ibr")])
 
-(define_insn "*builtin_setjmp_receiver_er_sl_1"
-  [(unspec_volatile [(label_ref (match_operand 0 "" ""))] UNSPECV_SETJMPR)]
-  "TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS"
-  "lda $27,$LSJ%=-%l0($27)\n$LSJ%=:")
-  
-(define_insn "*builtin_setjmp_receiver_er_1"
-  [(unspec_volatile [(label_ref (match_operand 0 "" ""))] UNSPECV_SETJMPR)]
-  "TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF"
-  "br $27,$LSJ%=\n$LSJ%=:"
-  [(set_attr "type" "ibr")])
-
-(define_split
-  [(unspec_volatile [(label_ref (match_operand 0 "" ""))] UNSPECV_SETJMPR)]
-  "TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF
-   && prev_nonnote_insn (insn) == operands[0]"
-  [(const_int 0)]
-  "
-{
-  emit_note (NULL, NOTE_INSN_DELETED);
-  DONE;
-}")
-
-(define_insn "*builtin_setjmp_receiver_1"
+(define_expand "builtin_setjmp_receiver"
   [(unspec_volatile [(label_ref (match_operand 0 "" ""))] UNSPECV_SETJMPR)]
   "TARGET_ABI_OSF"
-  "br $27,$LSJ%=\n$LSJ%=:\;ldgp $29,0($27)"
-  [(set_attr "length" "12")
-   (set_attr "type" "multi")])
+  "")
 
-(define_expand "builtin_setjmp_receiver_er"
-  [(unspec_volatile [(label_ref (match_operand 0 "" ""))] UNSPECV_SETJMPR)
+(define_insn_and_split "*builtin_setjmp_receiver_1"
+  [(unspec_volatile [(match_operand 0 "" "")] UNSPECV_SETJMPR)]
+  "TARGET_ABI_OSF"
+{
+  if (TARGET_EXPLICIT_RELOCS)
+    return "#";
+  else
+    return "br $27,$LSJ%=\n$LSJ%=:\;ldgp $29,0($27)";
+}
+  "&& TARGET_EXPLICIT_RELOCS && reload_completed"
+  [(unspec_volatile [(match_dup 0)] UNSPECV_SETJMPR_ER)
    (set (match_dup 1)
 	(unspec_volatile:DI [(match_dup 2) (match_dup 3)] UNSPECV_LDGP1))
    (set (match_dup 1)
 	(unspec:DI [(match_dup 1) (match_dup 3)] UNSPEC_LDGP2))]
-  ""
 {
   operands[1] = pic_offset_table_rtx;
   operands[2] = gen_rtx_REG (Pmode, 27);
   operands[3] = GEN_INT (alpha_next_sequence_number++);
-})
+}
+  [(set_attr "length" "12")
+   (set_attr "type" "multi")])
 
-(define_expand "builtin_setjmp_receiver"
-  [(unspec_volatile [(label_ref (match_operand 0 "" ""))] UNSPECV_SETJMPR)]
-  "TARGET_ABI_OSF"
-{
-  if (TARGET_EXPLICIT_RELOCS)
-    {
-      emit_insn (gen_builtin_setjmp_receiver_er (operands[0]));
-      DONE;
-    }
-})
+(define_insn "*builtin_setjmp_receiver_er_sl_1"
+  [(unspec_volatile [(match_operand 0 "" "")] UNSPECV_SETJMPR_ER)]
+  "TARGET_ABI_OSF && TARGET_EXPLICIT_RELOCS && TARGET_AS_CAN_SUBTRACT_LABELS"
+  "lda $27,$LSJ%=-%l0($27)\n$LSJ%=:")
 
-(define_expand "exception_receiver_er"
-  [(set (match_dup 0)
-	(unspec_volatile:DI [(match_dup 1) (match_dup 2)] UNSPECV_LDGP1))
-   (set (match_dup 0)
-	(unspec:DI [(match_dup 0) (match_dup 2)] UNSPEC_LDGP2))]
-  ""
-{
-  operands[0] = pic_offset_table_rtx;
-  operands[1] = gen_rtx_REG (Pmode, 26);
-  operands[2] = GEN_INT (alpha_next_sequence_number++);
-})
+(define_insn "*builtin_setjmp_receiver_er_1"
+  [(unspec_volatile [(match_operand 0 "" "")] UNSPECV_SETJMPR_ER)]
+  "TARGET_ABI_OSF && TARGET_EXPLICIT_RELOCS"
+  "br $27,$LSJ%=\n$LSJ%=:"
+  [(set_attr "type" "ibr")])
 
 (define_expand "exception_receiver"
   [(unspec_volatile [(match_dup 0)] UNSPECV_EHR)]
@@ -6835,28 +6810,38 @@
 {
   if (TARGET_LD_BUGGY_LDGP)
     operands[0] = alpha_gp_save_rtx ();
-  else if (TARGET_EXPLICIT_RELOCS)
-    {
-      emit_insn (gen_exception_receiver_er ());
-      DONE;
-    }
   else
     operands[0] = const0_rtx;
 })
 
-(define_insn "*exception_receiver_1"
-  [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]
-  "! TARGET_LD_BUGGY_LDGP"
-  "ldgp $29,0($26)"
-  [(set_attr "length" "8")
-   (set_attr "type" "multi")])
-
 (define_insn "*exception_receiver_2"
   [(unspec_volatile [(match_operand:DI 0 "memory_operand" "m")] UNSPECV_EHR)]
-  "TARGET_LD_BUGGY_LDGP"
+  "TARGET_ABI_OSF && TARGET_LD_BUGGY_LDGP"
   "ldq $29,%0"
   [(set_attr "type" "ild")])
 
+(define_insn_and_split "*exception_receiver_1"
+  [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]
+  "TARGET_ABI_OSF"
+{
+  if (TARGET_EXPLICIT_RELOCS)
+    return "ldah $29,0($26)\t\t!gpdisp!%*\;lda $29,0($29)\t\t!gpdisp!%*";
+  else
+    return "ldgp $29,0($26)";
+}
+  "&& TARGET_EXPLICIT_RELOCS && reload_completed"
+  [(set (match_dup 0)
+	(unspec_volatile:DI [(match_dup 1) (match_dup 2)] UNSPECV_LDGP1))
+   (set (match_dup 0)
+	(unspec:DI [(match_dup 0) (match_dup 2)] UNSPEC_LDGP2))]
+{
+  operands[0] = pic_offset_table_rtx;
+  operands[1] = gen_rtx_REG (Pmode, 26);
+  operands[2] = GEN_INT (alpha_next_sequence_number++);
+}
+  [(set_attr "length" "8")
+   (set_attr "type" "multi")])
+
 (define_expand "nonlocal_goto_receiver"
   [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)
    (set (reg:DI 27) (mem:DI (reg:DI 29)))
Index: gcc/config/alpha/qrnnd.asm
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/alpha/qrnnd.asm,v
retrieving revision 1.1
retrieving revision 1.1.60.1
diff -u -r1.1 -r1.1.60.1
--- gcc/gcc/config/alpha/qrnnd.asm	15 Apr 2000 16:34:38 -0000	1.1
+++ gcc/gcc/config/alpha/qrnnd.asm	30 Sep 2004 19:36:28 -0000	1.1.60.1
@@ -26,6 +26,10 @@
  # Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  # MA 02111-1307, USA.
 
+#ifdef __ELF__
+.section .note.GNU-stack,""
+#endif
+
         .set noreorder
         .set noat
 
Index: gcc/config/i386/i386-protos.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386-protos.h,v
retrieving revision 1.86.2.2
retrieving revision 1.86.2.3
diff -u -r1.86.2.2 -r1.86.2.3
--- gcc/gcc/config/i386/i386-protos.h	8 Jul 2003 19:16:44 -0000	1.86.2.2
+++ gcc/gcc/config/i386/i386-protos.h	12 Dec 2004 21:00:44 -0000	1.86.2.3
@@ -88,6 +88,8 @@
 extern int cmpsi_operand PARAMS ((rtx, enum machine_mode));
 extern int long_memory_operand PARAMS ((rtx, enum machine_mode));
 extern int aligned_operand PARAMS ((rtx, enum machine_mode));
+extern int compare_operator PARAMS ((rtx, enum machine_mode));
+extern int flags_reg_operand PARAMS ((rtx, enum machine_mode));
 extern enum machine_mode ix86_cc_mode PARAMS ((enum rtx_code, rtx, rtx));
 
 extern int ix86_expand_movstr PARAMS ((rtx, rtx, rtx, rtx));
Index: gcc/config/i386/i386.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386.c,v
retrieving revision 1.495.2.36
retrieving revision 1.495.2.37
diff -u -r1.495.2.36 -r1.495.2.37
--- gcc/gcc/config/i386/i386.c	18 May 2004 05:07:52 -0000	1.495.2.36
+++ gcc/gcc/config/i386/i386.c	12 Dec 2004 21:00:44 -0000	1.495.2.37
@@ -3609,6 +3609,20 @@
   return ANY_QI_REG_P (op);
 }
 
+/* Return true if op is an flags register.  */
+
+int
+flags_reg_operand (op, mode)
+     register rtx op;
+     enum machine_mode mode;
+{
+  if (mode != VOIDmode && GET_MODE (op) != mode)
+    return 0;
+  return (GET_CODE (op) == REG
+	  && REGNO (op) == FLAGS_REG
+	  && GET_MODE (op) != VOIDmode);
+}
+
 /* Return true if op is a NON_Q_REGS class register.  */
 
 int
@@ -3969,6 +3983,14 @@
   /* Didn't find one -- this must be an aligned address.  */
   return 1;
 }
+
+int
+compare_operator (op, mode)
+     rtx op;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return GET_CODE (op) == COMPARE;
+}
 
 /* Return true if the constant is something that can be loaded with
    a special instruction.  Only handle 0.0 and 1.0; others are less
Index: gcc/config/i386/i386.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386.h,v
retrieving revision 1.309.2.11
retrieving revision 1.309.2.12
diff -u -r1.309.2.11 -r1.309.2.12
--- gcc/gcc/config/i386/i386.h	6 Feb 2004 19:43:31 -0000	1.309.2.11
+++ gcc/gcc/config/i386/i386.h	12 Dec 2004 21:00:47 -0000	1.309.2.12
@@ -3319,6 +3319,7 @@
 			SYMBOL_REF, LABEL_REF, SUBREG, REG, MEM}},	\
   {"nonmemory_no_elim_operand", {CONST_INT, REG, SUBREG}},		\
   {"index_register_operand", {SUBREG, REG}},				\
+  {"flags_reg_operand", {REG}},						\
   {"q_regs_operand", {SUBREG, REG}},					\
   {"non_q_regs_operand", {SUBREG, REG}},				\
   {"fcmov_comparison_operator", {EQ, NE, LTU, GTU, LEU, GEU, UNORDERED, \
@@ -3354,6 +3355,7 @@
   {"fp_register_operand", {REG}},					\
   {"register_and_not_fp_reg_operand", {REG}},				\
   {"vector_move_operand", {CONST_VECTOR, SUBREG, REG, MEM}},		\
+  {"compare_operator", {COMPARE}},
 
 /* A list of predicates that do special things with modes, and so
    should not elicit warnings for VOIDmode match_operand.  */
Index: gcc/config/i386/i386.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386.md,v
retrieving revision 1.404.2.24
retrieving revision 1.404.2.29
diff -u -r1.404.2.24 -r1.404.2.29
--- gcc/gcc/config/i386/i386.md	28 Apr 2004 17:00:03 -0000	1.404.2.24
+++ gcc/gcc/config/i386/i386.md	23 Jan 2005 05:15:59 -0000	1.404.2.29
@@ -1188,10 +1188,9 @@
   ""
   "xchg{l}\t%1, %0"
   [(set_attr "type" "imov")
+   (set_attr "mode" "SI")
    (set_attr "pent_pair" "np")
    (set_attr "athlon_decode" "vector")
-   (set_attr "mode" "SI")
-   (set_attr "modrm" "0")
    (set_attr "ppro_uops" "few")])
 
 (define_expand "movhi"
@@ -1304,12 +1303,12 @@
 	(match_operand:HI 1 "register_operand" "+r"))
    (set (match_dup 1)
 	(match_dup 0))]
-  "TARGET_PARTIAL_REG_STALL"
-  "xchg{w}\t%1, %0"
+  "!TARGET_PARTIAL_REG_STALL || optimize_size"
+  "xchg{l}\t%k1, %k0"
   [(set_attr "type" "imov")
+   (set_attr "mode" "SI")
    (set_attr "pent_pair" "np")
-   (set_attr "mode" "HI")
-   (set_attr "modrm" "0")
+   (set_attr "athlon_decode" "vector")
    (set_attr "ppro_uops" "few")])
 
 (define_insn "*swaphi_2"
@@ -1317,12 +1316,12 @@
 	(match_operand:HI 1 "register_operand" "+r"))
    (set (match_dup 1)
 	(match_dup 0))]
-  "! TARGET_PARTIAL_REG_STALL"
-  "xchg{l}\t%k1, %k0"
+  "TARGET_PARTIAL_REG_STALL"
+  "xchg{w}\t%1, %0"
   [(set_attr "type" "imov")
+   (set_attr "mode" "HI")
    (set_attr "pent_pair" "np")
-   (set_attr "mode" "SI")
-   (set_attr "modrm" "0")
+   (set_attr "athlon_decode" "vector")
    (set_attr "ppro_uops" "few")])
 
 (define_expand "movstricthi"
@@ -1470,17 +1469,30 @@
   DONE;
 })
 
-(define_insn "*swapqi"
+(define_insn "*swapqi_1"
   [(set (match_operand:QI 0 "register_operand" "+r")
 	(match_operand:QI 1 "register_operand" "+r"))
    (set (match_dup 1)
 	(match_dup 0))]
-  ""
-  "xchg{b}\t%1, %0"
+  "!TARGET_PARTIAL_REG_STALL || optimize_size"
+  "xchg{l}\t%k1, %k0"
   [(set_attr "type" "imov")
+   (set_attr "mode" "SI")
    (set_attr "pent_pair" "np")
+   (set_attr "athlon_decode" "vector")
+   (set_attr "ppro_uops" "few")])
+
+(define_insn "*swapqi_2"
+  [(set (match_operand:QI 0 "register_operand" "+q")
+	(match_operand:QI 1 "register_operand" "+q"))
+   (set (match_dup 1)
+	(match_dup 0))]
+  "TARGET_PARTIAL_REG_STALL"
+  "xchg{b}\t%1, %0"
+  [(set_attr "type" "imov")
    (set_attr "mode" "QI")
-   (set_attr "modrm" "0")
+   (set_attr "pent_pair" "np")
+   (set_attr "athlon_decode" "vector")
    (set_attr "ppro_uops" "few")])
 
 (define_expand "movstrictqi"
@@ -1987,13 +1999,11 @@
   "TARGET_64BIT"
   "xchg{q}\t%1, %0"
   [(set_attr "type" "imov")
+   (set_attr "mode" "DI")
    (set_attr "pent_pair" "np")
    (set_attr "athlon_decode" "vector")
-   (set_attr "mode" "DI")
-   (set_attr "modrm" "0")
    (set_attr "ppro_uops" "few")])
 
-  
 (define_expand "movsf"
   [(set (match_operand:SF 0 "nonimmediate_operand" "")
 	(match_operand:SF 1 "general_operand" ""))]
@@ -7559,17 +7569,21 @@
   ""
   "")
 
-(define_insn "*testqi_1"
+(define_insn "*testqi_1_maybe_si"
   [(set (reg 17)
-        (compare (and:QI (match_operand:QI 0 "nonimmediate_operand" "%*a,q,qm,r")
-			 (match_operand:QI 1 "nonmemory_operand" "n,n,qn,n"))
-		 (const_int 0)))]
-  "ix86_match_ccmode (insn, CCNOmode)"
+        (compare
+	  (and:QI
+	    (match_operand:QI 0 "nonimmediate_operand" "%*a,q,qm,r")
+	    (match_operand:QI 1 "nonmemory_operand" "n,n,qn,n"))
+	  (const_int 0)))]
+   "(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)
+    && ix86_match_ccmode (insn,
+ 			  GET_CODE (operands[1]) == CONST_INT
+ 			  && INTVAL (operands[1]) >= 0 ? CCNOmode : CCZmode)"
 {
   if (which_alternative == 3)
     {
-      if (GET_CODE (operands[1]) == CONST_INT
-	  && (INTVAL (operands[1]) & 0xffffff00))
+      if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) < 0)
 	operands[1] = GEN_INT (INTVAL (operands[1]) & 0xff);
       return "test{l}\t{%1, %k0|%k0, %1}";
     }
@@ -7580,6 +7594,18 @@
    (set_attr "mode" "QI,QI,QI,SI")
    (set_attr "pent_pair" "uv,np,uv,np")])
 
+(define_insn "*testqi_1"
+  [(set (reg 17)
+        (compare (and:QI (match_operand:QI 0 "nonimmediate_operand" "%*a,q,qm")
+			 (match_operand:QI 1 "nonmemory_operand" "n,n,qn"))
+		 (const_int 0)))]
+  "ix86_match_ccmode (insn, CCNOmode)"
+  "test{b}\t{%1, %0|%0, %1}"
+  [(set_attr "type" "test")
+   (set_attr "modrm" "0,1,1")
+   (set_attr "mode" "QI")
+   (set_attr "pent_pair" "uv,np,uv")])
+
 (define_expand "testqi_ext_ccno_0"
   [(set (reg:CCNO 17)
 	(compare:CCNO
@@ -7697,51 +7723,53 @@
   "#")
 
 (define_split
-  [(set (reg 17)
-        (compare (zero_extract
-		   (match_operand 0 "nonimmediate_operand" "")
-		   (match_operand 1 "const_int_operand" "")
-		   (match_operand 2 "const_int_operand" ""))
-		 (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+        (match_operator 1 "compare_operator"
+	  [(zero_extract
+	     (match_operand 2 "nonimmediate_operand" "")
+	     (match_operand 3 "const_int_operand" "")
+	     (match_operand 4 "const_int_operand" ""))
+	   (const_int 0)]))]
   "ix86_match_ccmode (insn, CCNOmode)"
-  [(set (reg:CCNO 17) (compare:CCNO (match_dup 3) (const_int 0)))]
+  [(set (match_dup 0) (match_op_dup 1 [(match_dup 2) (const_int 0)]))]
 {
-  HOST_WIDE_INT len = INTVAL (operands[1]);
-  HOST_WIDE_INT pos = INTVAL (operands[2]);
+  rtx val = operands[2];
+  HOST_WIDE_INT len = INTVAL (operands[3]);
+  HOST_WIDE_INT pos = INTVAL (operands[4]);
   HOST_WIDE_INT mask;
   enum machine_mode mode, submode;
 
-  mode = GET_MODE (operands[0]);
-  if (GET_CODE (operands[0]) == MEM)
+  mode = GET_MODE (val);
+  if (GET_CODE (val) == MEM)
     {
       /* ??? Combine likes to put non-volatile mem extractions in QImode
 	 no matter the size of the test.  So find a mode that works.  */
-      if (! MEM_VOLATILE_P (operands[0]))
+      if (! MEM_VOLATILE_P (val))
 	{
 	  mode = smallest_mode_for_size (pos + len, MODE_INT);
-	  operands[0] = adjust_address (operands[0], mode, 0);
+	  val = adjust_address (val, mode, 0);
 	}
     }
-  else if (GET_CODE (operands[0]) == SUBREG
-	   && (submode = GET_MODE (SUBREG_REG (operands[0])),
+  else if (GET_CODE (val) == SUBREG
+	   && (submode = GET_MODE (SUBREG_REG (val)),
 	       GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (submode))
 	   && pos + len <= GET_MODE_BITSIZE (submode))
     {
       /* Narrow a paradoxical subreg to prevent partial register stalls.  */
       mode = submode;
-      operands[0] = SUBREG_REG (operands[0]);
+      val = SUBREG_REG (val);
     }
   else if (mode == HImode && pos + len <= 8)
     {
       /* Small HImode tests can be converted to QImode.  */
       mode = QImode;
-      operands[0] = gen_lowpart (QImode, operands[0]);
+      val = gen_lowpart (QImode, val);
     }
 
   mask  = ((HOST_WIDE_INT)1 << (pos + len)) - 1;
   mask &= ~(((HOST_WIDE_INT)1 << pos) - 1);
 
-  operands[3] = gen_rtx_AND (mode, operands[0], gen_int_mode (mask, mode));
+  operands[2] = gen_rtx_AND (mode, val, gen_int_mode (mask, mode));
 })
 
 ;; Convert HImode/SImode test instructions with immediate to QImode ones.
@@ -7750,46 +7778,44 @@
 ;; Do the converison only post-reload to avoid limiting of the register class
 ;; to QI regs.
 (define_split
-  [(set (reg 17)
-	(compare
-	  (and (match_operand 0 "register_operand" "")
-	       (match_operand 1 "const_int_operand" ""))
-	  (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(and (match_operand 2 "register_operand" "")
+	        (match_operand 3 "const_int_operand" ""))
+	   (const_int 0)]))]
    "reload_completed
-    && QI_REG_P (operands[0])
+    && QI_REG_P (operands[2])
+    && GET_MODE (operands[2]) != QImode
     && ((ix86_match_ccmode (insn, CCZmode)
-    	 && !(INTVAL (operands[1]) & ~(255 << 8)))
+    	 && !(INTVAL (operands[3]) & ~(255 << 8)))
 	|| (ix86_match_ccmode (insn, CCNOmode)
-	    && !(INTVAL (operands[1]) & ~(127 << 8))))
-    && GET_MODE (operands[0]) != QImode"
-  [(set (reg:CCNO 17)
-	(compare:CCNO
-	  (and:SI (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))
-		  (match_dup 1))
-	  (const_int 0)))]
-  "operands[0] = gen_lowpart (SImode, operands[0]);
-   operands[1] = gen_int_mode (INTVAL (operands[1]) >> 8, SImode);")
+	    && !(INTVAL (operands[3]) & ~(127 << 8))))"
+  [(set (match_dup 0)
+	(match_op_dup 1
+	  [(and:SI (zero_extract:SI (match_dup 2) (const_int 8) (const_int 8))
+		   (match_dup 3))
+	   (const_int 0)]))]
+  "operands[2] = gen_lowpart (SImode, operands[2]);
+   operands[3] = gen_int_mode (INTVAL (operands[3]) >> 8, SImode);")
 
 (define_split
-  [(set (reg 17)
-	(compare
-	  (and (match_operand 0 "nonimmediate_operand" "")
-	       (match_operand 1 "const_int_operand" ""))
-	  (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(and (match_operand 2 "nonimmediate_operand" "")
+	        (match_operand 3 "const_int_operand" ""))
+	   (const_int 0)]))]
    "reload_completed
-    && (!REG_P (operands[0]) || ANY_QI_REG_P (operands[0]))
+    && GET_MODE (operands[2]) != QImode
+    && (!REG_P (operands[2]) || ANY_QI_REG_P (operands[2]))
     && ((ix86_match_ccmode (insn, CCZmode)
-	 && !(INTVAL (operands[1]) & ~255))
+	 && !(INTVAL (operands[3]) & ~255))
 	|| (ix86_match_ccmode (insn, CCNOmode)
-	    && !(INTVAL (operands[1]) & ~127)))
-    && GET_MODE (operands[0]) != QImode"
-  [(set (reg:CCNO 17)
-	(compare:CCNO
-	  (and:QI (match_dup 0)
-		  (match_dup 1))
-	  (const_int 0)))]
-  "operands[0] = gen_lowpart (QImode, operands[0]);
-   operands[1] = gen_lowpart (QImode, operands[1]);")
+	    && !(INTVAL (operands[3]) & ~127)))"
+  [(set (match_dup 0)
+	(match_op_dup 1 [(and:QI (match_dup 2) (match_dup 3))
+			 (const_int 0)]))]
+  "operands[2] = gen_lowpart (QImode, operands[2]);
+   operands[3] = gen_lowpart (QImode, operands[3]);")
 
 
 ;; %%% This used to optimize known byte-wide and operations to memory,
@@ -8066,7 +8092,7 @@
   [(set_attr "type" "alu1")
    (set_attr "mode" "QI")])
 
-(define_insn "*andqi_2"
+(define_insn "*andqi_2_maybe_si"
   [(set (reg 17)
 	(compare (and:QI
 		   (match_operand:QI 1 "nonimmediate_operand" "%0,0,0")
@@ -8074,13 +8100,14 @@
 		 (const_int 0)))
    (set (match_operand:QI 0 "nonimmediate_operand" "=q,qm,*r")
 	(and:QI (match_dup 1) (match_dup 2)))]
-  "ix86_match_ccmode (insn, CCNOmode)
-   && ix86_binary_operator_ok (AND, QImode, operands)"
+   "ix86_binary_operator_ok (AND, QImode, operands)
+    && ix86_match_ccmode (insn,
+ 			  GET_CODE (operands[2]) == CONST_INT
+ 			  && INTVAL (operands[2]) >= 0 ? CCNOmode : CCZmode)"
 {
   if (which_alternative == 2)
     {
-      if (GET_CODE (operands[2]) == CONST_INT
-          && (INTVAL (operands[2]) & 0xffffff00))
+      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
         operands[2] = GEN_INT (INTVAL (operands[2]) & 0xff);
       return "and{l}\t{%2, %k0|%k0, %2}";
     }
@@ -8089,6 +8116,20 @@
   [(set_attr "type" "alu")
    (set_attr "mode" "QI,QI,SI")])
 
+(define_insn "*andqi_2"
+  [(set (reg 17)
+	(compare (and:QI
+		   (match_operand:QI 1 "nonimmediate_operand" "%0,0")
+		   (match_operand:QI 2 "general_operand" "qim,qi"))
+		 (const_int 0)))
+   (set (match_operand:QI 0 "nonimmediate_operand" "=q,qm")
+	(and:QI (match_dup 1) (match_dup 2)))]
+  "ix86_match_ccmode (insn, CCNOmode)
+   && ix86_binary_operator_ok (AND, QImode, operands)"
+  "and{b}\t{%2, %0|%0, %2}"
+  [(set_attr "type" "alu")
+   (set_attr "mode" "QI")])
+
 (define_insn "*andqi_2_slp"
   [(set (reg 17)
 	(compare (and:QI
@@ -10147,17 +10188,19 @@
    (set_attr "mode" "DI")])
 
 (define_split
-  [(set (reg 17)
-	(compare (not:DI (match_operand:DI 1 "nonimmediate_operand" ""))
-		 (const_int 0)))
-   (set (match_operand:DI 0 "nonimmediate_operand" "")
-	(not:DI (match_dup 1)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 2 "compare_operator"
+	  [(not:DI (match_operand:DI 3 "nonimmediate_operand" ""))
+	   (const_int 0)]))
+   (set (match_operand:DI 1 "nonimmediate_operand" "")
+	(not:DI (match_dup 3)))]
   "TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO (xor:DI (match_dup 1) (const_int -1))
-				 (const_int 0)))
-	      (set (match_dup 0)
-		   (xor:DI (match_dup 1) (const_int -1)))])]
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 2
+		     [(xor:DI (match_dup 3) (const_int -1))
+		      (const_int 0)]))
+	      (set (match_dup 1)
+		   (xor:DI (match_dup 3) (const_int -1)))])]
   "")
 
 (define_expand "one_cmplsi2"
@@ -10196,17 +10239,18 @@
    (set_attr "mode" "SI")])
 
 (define_split
-  [(set (reg 17)
-	(compare (not:SI (match_operand:SI 1 "nonimmediate_operand" ""))
-		 (const_int 0)))
-   (set (match_operand:SI 0 "nonimmediate_operand" "")
-	(not:SI (match_dup 1)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 2 "compare_operator"
+	  [(not:SI (match_operand:SI 3 "nonimmediate_operand" ""))
+	   (const_int 0)]))
+   (set (match_operand:SI 1 "nonimmediate_operand" "")
+	(not:SI (match_dup 3)))]
   "ix86_match_ccmode (insn, CCNOmode)"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO (xor:SI (match_dup 1) (const_int -1))
-				 (const_int 0)))
-	      (set (match_dup 0)
-		   (xor:SI (match_dup 1) (const_int -1)))])]
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 2 [(xor:SI (match_dup 3) (const_int -1))
+				    (const_int 0)]))
+	      (set (match_dup 1)
+		   (xor:SI (match_dup 3) (const_int -1)))])]
   "")
 
 ;; ??? Currently never generated - xor is used instead.
@@ -10223,17 +10267,18 @@
    (set_attr "mode" "SI")])
 
 (define_split
-  [(set (reg 17)
-	(compare (not:SI (match_operand:SI 1 "register_operand" ""))
-		 (const_int 0)))
-   (set (match_operand:DI 0 "register_operand" "")
-	(zero_extend:DI (not:SI (match_dup 1))))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 2 "compare_operator"
+	  [(not:SI (match_operand:SI 3 "register_operand" ""))
+	   (const_int 0)]))
+   (set (match_operand:DI 1 "register_operand" "")
+	(zero_extend:DI (not:SI (match_dup 3))))]
   "ix86_match_ccmode (insn, CCNOmode)"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO (xor:SI (match_dup 1) (const_int -1))
-				 (const_int 0)))
-	      (set (match_dup 0)
-		   (zero_extend:DI (xor:SI (match_dup 1) (const_int -1))))])]
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 2 [(xor:SI (match_dup 3) (const_int -1))
+				    (const_int 0)]))
+	      (set (match_dup 1)
+		   (zero_extend:DI (xor:SI (match_dup 3) (const_int -1))))])]
   "")
 
 (define_expand "one_cmplhi2"
@@ -10263,17 +10308,18 @@
    (set_attr "mode" "HI")])
 
 (define_split
-  [(set (reg 17)
-	(compare (not:HI (match_operand:HI 1 "nonimmediate_operand" ""))
-		 (const_int 0)))
-   (set (match_operand:HI 0 "nonimmediate_operand" "")
-	(not:HI (match_dup 1)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 2 "compare_operator"
+	  [(not:HI (match_operand:HI 3 "nonimmediate_operand" ""))
+	   (const_int 0)]))
+   (set (match_operand:HI 1 "nonimmediate_operand" "")
+	(not:HI (match_dup 3)))]
   "ix86_match_ccmode (insn, CCNOmode)"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO (xor:HI (match_dup 1) (const_int -1))
-		      		 (const_int 0)))
-	      (set (match_dup 0)
-		   (xor:HI (match_dup 1) (const_int -1)))])]
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 2 [(xor:HI (match_dup 3) (const_int -1))
+		      		    (const_int 0)]))
+	      (set (match_dup 1)
+		   (xor:HI (match_dup 3) (const_int -1)))])]
   "")
 
 ;; %%% Potential partial reg stall on alternative 1.  What to do?
@@ -10306,17 +10352,18 @@
    (set_attr "mode" "QI")])
 
 (define_split
-  [(set (reg 17)
-	(compare (not:QI (match_operand:QI 1 "nonimmediate_operand" ""))
-		 (const_int 0)))
-   (set (match_operand:QI 0 "nonimmediate_operand" "")
-	(not:QI (match_dup 1)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 2 "compare_operator"
+	  [(not:QI (match_operand:QI 3 "nonimmediate_operand" ""))
+	   (const_int 0)]))
+   (set (match_operand:QI 1 "nonimmediate_operand" "")
+	(not:QI (match_dup 3)))]
   "ix86_match_ccmode (insn, CCNOmode)"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO (xor:QI (match_dup 1) (const_int -1))
-		      		 (const_int 0)))
-	      (set (match_dup 0)
-		   (xor:QI (match_dup 1) (const_int -1)))])]
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 2 [(xor:QI (match_dup 3) (const_int -1))
+		      		    (const_int 0)]))
+	      (set (match_dup 1)
+		   (xor:QI (match_dup 3) (const_int -1)))])]
   "")
 
 ;; Arithmetic shift instructions
@@ -16639,10 +16686,12 @@
    (set (subreg:TI (match_dup 0) 0) (ior:TI (subreg:TI (match_dup 6) 0)
 					    (subreg:TI (match_dup 7) 0)))]
 {
-  /* If op2 == op3, op3 will be clobbered before it is used.
-     This should be optimized out though.  */
+  /* If op2 == op3, op3 would be clobbered before it is used.  */
   if (operands_match_p (operands[2], operands[3]))
-    abort ();
+    {
+      emit_move_insn (operands[0], operands[2]);
+      DONE;
+    }
   PUT_MODE (operands[1], GET_MODE (operands[0]));
   if (operands_match_p (operands[0], operands[4]))
     operands[6] = operands[4], operands[7] = operands[2];
@@ -16863,52 +16912,56 @@
 ; instruction size is unchanged, except in the %eax case for
 ; which it is increased by one byte, hence the ! optimize_size.
 (define_split
-  [(set (reg 17)
-	(compare (and (match_operand 1 "aligned_operand" "")
-		      (match_operand 2 "const_int_operand" ""))
-		 (const_int 0)))
-   (set (match_operand 0 "register_operand" "")
-	(and (match_dup 1) (match_dup 2)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 2 "compare_operator"
+	  [(and (match_operand 3 "aligned_operand" "")
+		(match_operand 4 "const_int_operand" ""))
+	   (const_int 0)]))
+   (set (match_operand 1 "register_operand" "")
+	(and (match_dup 3) (match_dup 4)))]
   "! TARGET_PARTIAL_REG_STALL && reload_completed
    /* Ensure that the operand will remain sign-extended immediate.  */
-   && ix86_match_ccmode (insn, INTVAL (operands[2]) >= 0 ? CCNOmode : CCZmode)
+   && ix86_match_ccmode (insn, INTVAL (operands[4]) >= 0 ? CCNOmode : CCZmode)
    && ! optimize_size
-   && ((GET_MODE (operands[0]) == HImode && ! TARGET_FAST_PREFIX)
-       || (GET_MODE (operands[0]) == QImode && TARGET_PROMOTE_QImode))"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO (and:SI (match_dup 1) (match_dup 2))
-			         (const_int 0)))
-	      (set (match_dup 0)
-		   (and:SI (match_dup 1) (match_dup 2)))])]
-  "operands[2]
-     = gen_int_mode (INTVAL (operands[2])
-		     & GET_MODE_MASK (GET_MODE (operands[0])),
-		     SImode);
-   operands[0] = gen_lowpart (SImode, operands[0]);
-   operands[1] = gen_lowpart (SImode, operands[1]);")
+   && ((GET_MODE (operands[1]) == HImode && ! TARGET_FAST_PREFIX)
+       || (GET_MODE (operands[1]) == QImode && TARGET_PROMOTE_QImode))"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 2 [(and:SI (match_dup 3) (match_dup 4))
+			            (const_int 0)]))
+	      (set (match_dup 1)
+		   (and:SI (match_dup 3) (match_dup 4)))])]
+{
+  operands[4]
+    = gen_int_mode (INTVAL (operands[4])
+		    & GET_MODE_MASK (GET_MODE (operands[1])), SImode);
+  operands[1] = gen_lowpart (SImode, operands[1]);
+  operands[3] = gen_lowpart (SImode, operands[3]);
+})
 
 ; Don't promote the QImode tests, as i386 doesn't have encoding of
 ; the TEST instruction with 32-bit sign-extended immediate and thus
 ; the instruction size would at least double, which is not what we
 ; want even with ! optimize_size.
 (define_split
-  [(set (reg 17)
-	(compare (and (match_operand:HI 0 "aligned_operand" "")
-		      (match_operand:HI 1 "const_int_operand" ""))
-		 (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(and (match_operand:HI 2 "aligned_operand" "")
+		(match_operand:HI 3 "const_int_operand" ""))
+	   (const_int 0)]))]
   "! TARGET_PARTIAL_REG_STALL && reload_completed
    /* Ensure that the operand will remain sign-extended immediate.  */
-   && ix86_match_ccmode (insn, INTVAL (operands[1]) >= 0 ? CCNOmode : CCZmode)
+   && ix86_match_ccmode (insn, INTVAL (operands[3]) >= 0 ? CCNOmode : CCZmode)
    && ! TARGET_FAST_PREFIX
    && ! optimize_size"
-  [(set (reg:CCNO 17)
-	(compare:CCNO (and:SI (match_dup 0) (match_dup 1))
-		      (const_int 0)))]
-  "operands[1]
-     = gen_int_mode (INTVAL (operands[1])
-		     & GET_MODE_MASK (GET_MODE (operands[0])),
-		     SImode);
-   operands[0] = gen_lowpart (SImode, operands[0]);")
+  [(set (match_dup 0)
+	(match_op_dup 1 [(and:SI (match_dup 2) (match_dup 3))
+		         (const_int 0)]))]
+{
+  operands[3]
+    = gen_int_mode (INTVAL (operands[3])
+		    & GET_MODE_MASK (GET_MODE (operands[2])), SImode);
+  operands[2] = gen_lowpart (SImode, operands[2]);
+})
 
 (define_split
   [(set (match_operand 0 "register_operand" "")
@@ -17081,13 +17134,14 @@
 
 ;; Don't compare memory with zero, load and use a test instead.
 (define_peephole2
-  [(set (reg 17)
-	(compare (match_operand:SI 0 "memory_operand" "")
-	         (const_int 0)))
+  [(set (match_operand 0 "flags_reg_operand" "")
+ 	(match_operator 1 "compare_operator"
+	  [(match_operand:SI 2 "memory_operand" "")
+	   (const_int 0)]))
    (match_scratch:SI 3 "r")]
   "ix86_match_ccmode (insn, CCNOmode) && ! optimize_size"
-  [(set (match_dup 3) (match_dup 0))
-   (set (reg:CCNO 17) (compare:CCNO (match_dup 3) (const_int 0)))]
+  [(set (match_dup 3) (match_dup 2))
+   (set (match_dup 0) (match_op_dup 1 [(match_dup 3) (const_int 0)]))]
   "")
 
 ;; NOT is not pairable on Pentium, while XOR is, but one byte longer. 
@@ -17151,77 +17205,77 @@
 ;; versions if we're concerned about partial register stalls.
 
 (define_peephole2
-  [(set (reg 17)
-	(compare (and:SI (match_operand:SI 0 "register_operand" "")
-			 (match_operand:SI 1 "immediate_operand" ""))
-		 (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(and:SI (match_operand:SI 2 "register_operand" "")
+		   (match_operand:SI 3 "immediate_operand" ""))
+	   (const_int 0)]))]
   "ix86_match_ccmode (insn, CCNOmode)
-   && (true_regnum (operands[0]) != 0
-       || (GET_CODE (operands[1]) == CONST_INT
-	   && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')))
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
+   && (true_regnum (operands[2]) != 0
+       || (GET_CODE (operands[3]) == CONST_INT
+	   && CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'K')))
+   && peep2_reg_dead_p (1, operands[2])"
   [(parallel
-     [(set (reg:CCNO 17)
-	   (compare:CCNO (and:SI (match_dup 0)
-			         (match_dup 1))
-		         (const_int 0)))
-      (set (match_dup 0)
-	   (and:SI (match_dup 0) (match_dup 1)))])]
+     [(set (match_dup 0)
+	   (match_op_dup 1 [(and:SI (match_dup 2) (match_dup 3))
+		            (const_int 0)]))
+      (set (match_dup 2)
+	   (and:SI (match_dup 2) (match_dup 3)))])]
   "")
 
 ;; We don't need to handle HImode case, because it will be promoted to SImode
 ;; on ! TARGET_PARTIAL_REG_STALL
 
 (define_peephole2
-  [(set (reg 17)
-	(compare (and:QI (match_operand:QI 0 "register_operand" "")
-			 (match_operand:QI 1 "immediate_operand" ""))
-		 (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(and:QI (match_operand:QI 2 "register_operand" "")
+		   (match_operand:QI 3 "immediate_operand" ""))
+	   (const_int 0)]))]
   "! TARGET_PARTIAL_REG_STALL
    && ix86_match_ccmode (insn, CCNOmode)
-   && true_regnum (operands[0]) != 0
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
+   && true_regnum (operands[2]) != 0
+   && peep2_reg_dead_p (1, operands[2])"
   [(parallel
-     [(set (reg:CCNO 17)
-	   (compare:CCNO (and:QI (match_dup 0)
- 			         (match_dup 1))
-		         (const_int 0)))
-      (set (match_dup 0)
-	   (and:QI (match_dup 0) (match_dup 1)))])]
+     [(set (match_dup 0)
+	   (match_op_dup 1 [(and:QI (match_dup 2) (match_dup 3))
+		            (const_int 0)]))
+      (set (match_dup 2)
+	   (and:QI (match_dup 2) (match_dup 3)))])]
   "")
 
 (define_peephole2
-  [(set (reg 17)
-	(compare
-	  (and:SI
-	    (zero_extract:SI
-	      (match_operand 0 "ext_register_operand" "")
-	      (const_int 8)
-	      (const_int 8))
-	    (match_operand 1 "const_int_operand" ""))
-	  (const_int 0)))]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(and:SI
+	     (zero_extract:SI
+	       (match_operand 2 "ext_register_operand" "")
+	       (const_int 8)
+	       (const_int 8))
+	     (match_operand 3 "const_int_operand" ""))
+	   (const_int 0)]))]
   "! TARGET_PARTIAL_REG_STALL
    && ix86_match_ccmode (insn, CCNOmode)
-   && true_regnum (operands[0]) != 0
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
-  [(parallel [(set (reg:CCNO 17)
-		   (compare:CCNO
-		       (and:SI
-			 (zero_extract:SI
-			 (match_dup 0)
-			 (const_int 8)
-			 (const_int 8))
-			(match_dup 1))
-		   (const_int 0)))
-	      (set (zero_extract:SI (match_dup 0)
+   && true_regnum (operands[2]) != 0
+   && peep2_reg_dead_p (1, operands[2])"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1
+		     [(and:SI
+			(zero_extract:SI
+			  (match_dup 2)
+			  (const_int 8)
+			  (const_int 8))
+			(match_dup 3))
+		      (const_int 0)]))
+	      (set (zero_extract:SI (match_dup 2)
 				    (const_int 8)
 				    (const_int 8))
 		   (and:SI 
 		     (zero_extract:SI
-		       (match_dup 0)
+		       (match_dup 2)
 		       (const_int 8)
 		       (const_int 8))
-		     (match_dup 1)))])]
+		     (match_dup 3)))])]
   "")
 
 ;; Don't do logical operations with memory inputs.
@@ -17523,66 +17577,20 @@
   "")
 
 ;; Convert compares with 1 to shorter inc/dec operations when CF is not
-;; required and register dies.
-(define_peephole2
-  [(set (reg 17)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "incdec_operand" "")))]
-  "ix86_match_ccmode (insn, CCGCmode)
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
-  [(parallel [(set (reg:CCGC 17)
-		   (compare:CCGC (match_dup 0)
-				 (match_dup 1)))
-	      (clobber (match_dup 0))])]
-  "")
-
+;; required and register dies.  Similarly for 128 to plus -128.
 (define_peephole2
-  [(set (reg 17)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (match_operand:HI 1 "incdec_operand" "")))]
-  "ix86_match_ccmode (insn, CCGCmode)
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
-  [(parallel [(set (reg:CCGC 17)
-		   (compare:CCGC (match_dup 0)
-				 (match_dup 1)))
-	      (clobber (match_dup 0))])]
-  "")
-
-(define_peephole2
-  [(set (reg 17)
-	(compare (match_operand:QI 0 "register_operand" "")
-		 (match_operand:QI 1 "incdec_operand" "")))]
-  "ix86_match_ccmode (insn, CCGCmode)
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
-  [(parallel [(set (reg:CCGC 17)
-		   (compare:CCGC (match_dup 0)
-				 (match_dup 1)))
-	      (clobber (match_dup 0))])]
-  "")
-
-;; Convert compares with 128 to shorter add -128
-(define_peephole2
-  [(set (reg 17)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (const_int 128)))]
-  "ix86_match_ccmode (insn, CCGCmode)
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
-  [(parallel [(set (reg:CCGC 17)
-		   (compare:CCGC (match_dup 0)
-			         (const_int 128)))
-	      (clobber (match_dup 0))])]
-  "")
-
-(define_peephole2
-  [(set (reg 17)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (const_int 128)))]
-  "ix86_match_ccmode (insn, CCGCmode)
-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))"
-  [(parallel [(set (reg:CCGC 17)
-		   (compare:CCGC (match_dup 0)
-			         (const_int 128)))
-	      (clobber (match_dup 0))])]
+  [(set (match_operand 0 "flags_reg_operand" "")
+	(match_operator 1 "compare_operator"
+	  [(match_operand 2 "register_operand" "")
+	   (match_operand 3 "const_int_operand" "")]))]
+  "(INTVAL (operands[3]) == -1
+    || INTVAL (operands[3]) == 1
+    || INTVAL (operands[3]) == 128)
+   && ix86_match_ccmode (insn, CCGCmode)
+   && peep2_reg_dead_p (1, operands[2])"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1 [(match_dup 2) (match_dup 3)]))
+	      (clobber (match_dup 2))])]
   "")
 
 (define_peephole2
@@ -17780,9 +17788,9 @@
 	return "call\t%P1";
     }
   if (SIBLING_CALL_P (insn))
-    return "jmp\t%*%1";
+    return "jmp\t%A1";
   else
-    return "call\t%*%1";
+    return "call\t%A1";
 }
   [(set_attr "type" "callv")])
 
Index: gcc/config/ia64/ia64.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/ia64/ia64.c,v
retrieving revision 1.198.2.22
retrieving revision 1.198.2.24
diff -u -r1.198.2.22 -r1.198.2.24
--- gcc/gcc/config/ia64/ia64.c	17 Sep 2004 17:56:32 -0000	1.198.2.22
+++ gcc/gcc/config/ia64/ia64.c	14 Jan 2005 19:15:40 -0000	1.198.2.24
@@ -2884,10 +2884,13 @@
 	 preserve those input registers used as arguments to the sibling call.
 	 It is unclear how to compute that number here.  */
       if (current_frame_info.n_input_regs != 0)
-	emit_insn (gen_alloc (gen_rtx_REG (DImode, fp),
-			      GEN_INT (0), GEN_INT (0),
-			      GEN_INT (current_frame_info.n_input_regs),
-			      GEN_INT (0)));
+	{
+	  rtx n_inputs = GEN_INT (current_frame_info.n_input_regs);
+	  insn = emit_insn (gen_alloc (gen_rtx_REG (DImode, fp),
+				const0_rtx, const0_rtx,
+				n_inputs, const0_rtx));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
     }
 }
 
@@ -3021,15 +3024,16 @@
      int aligned_p;
 {
   if (size == (TARGET_ILP32 ? 4 : 8)
-      && aligned_p
       && !(TARGET_NO_PIC || TARGET_AUTO_PIC)
       && GET_CODE (x) == SYMBOL_REF
       && SYMBOL_REF_FLAG (x))
     {
-      if (TARGET_ILP32)
-	fputs ("\tdata4\t@fptr(", asm_out_file);
-      else
-	fputs ("\tdata8\t@fptr(", asm_out_file);
+      static const char * const directive[2][2] = {
+	  /* 64-bit pointer */  /* 32-bit pointer */
+	{ "\tdata8.ua\t@fptr(", "\tdata4.ua\t@fptr("},	/* unaligned */
+	{ "\tdata8\t@fptr(",    "\tdata4\t@fptr("}	/* aligned */
+      };
+      fputs (directive[aligned_p != 0][TARGET_ILP32 != 0], asm_out_file);
       output_addr_const (asm_out_file, x);
       fputs (")\n", asm_out_file);
       return true;
@@ -7451,13 +7455,24 @@
     {
       dest_regno = REGNO (dest);
 
-      /* If this isn't the final destination for ar.pfs, the alloc
-	 shouldn't have been marked frame related.  */
-      if (dest_regno != current_frame_info.reg_save_ar_pfs)
-	abort ();
-
-      fprintf (asm_out_file, "\t.save ar.pfs, r%d\n",
-	       ia64_dbx_register_number (dest_regno));
+      /* If this is the final destination for ar.pfs, then this must
+	 be the alloc in the prologue.  */
+      if (dest_regno == current_frame_info.reg_save_ar_pfs)
+	fprintf (asm_out_file, "\t.save ar.pfs, r%d\n",
+		 ia64_dbx_register_number (dest_regno));
+      else
+	{
+	  /* This must be an alloc before a sibcall.  We must drop the
+	     old frame info.  The easiest way to drop the old frame
+	     info is to ensure we had a ".restore sp" directive
+	     followed by a new prologue.  If the procedure doesn't
+	     have a memory-stack frame, we'll issue a dummy ".restore
+	     sp" now.  */
+	  if (current_frame_info.total_size == 0 && !frame_pointer_needed)
+	    /* if haven't done process_epilogue() yet, do it now */
+	    process_epilogue ();
+	  fprintf (asm_out_file, "\t.prologue\n");
+	}
       return 1;
     }
 
Index: gcc/config/m68hc11/t-m68hc11-gas
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/m68hc11/t-m68hc11-gas,v
retrieving revision 1.7.14.3
retrieving revision 1.7.14.4
diff -u -r1.7.14.3 -r1.7.14.4
--- gcc/gcc/config/m68hc11/t-m68hc11-gas	4 Oct 2003 19:45:57 -0000	1.7.14.3
+++ gcc/gcc/config/m68hc11/t-m68hc11-gas	28 Jan 2005 22:21:39 -0000	1.7.14.4
@@ -53,7 +53,7 @@
 dp-bit.c: $(srcdir)/config/fp-bit.c
 	echo '#define SMALL_MACHINE' >> dp-bit.c
 	echo '#define CMPtype HItype' >> dp-bit.c
-	echo '#ifdef __LITTLE_ENDIAN__' > dp-bit.c
+	echo '#ifdef __LITTLE_ENDIAN__' >> dp-bit.c
 	echo '#define FLOAT_BIT_ORDER_MISMATCH' >>dp-bit.c
 	echo '#endif' 		>> dp-bit.c
 	cat $(srcdir)/config/fp-bit.c >> dp-bit.c
Index: gcc/config/mips/mips-protos.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/mips/mips-protos.h,v
retrieving revision 1.30.4.1
retrieving revision 1.30.4.2
diff -u -r1.30.4.1 -r1.30.4.2
--- gcc/gcc/config/mips/mips-protos.h	31 Jan 2003 23:51:22 -0000	1.30.4.1
+++ gcc/gcc/config/mips/mips-protos.h	8 Jan 2005 14:33:32 -0000	1.30.4.2
@@ -1,6 +1,6 @@
 /* Prototypes of target machine for GNU compiler.  MIPS version.
    Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2001, 2002 Free Software Foundation, Inc.
+   1999, 2001, 2002, 2005 Free Software Foundation, Inc.
    Contributed by A. Lichnewsky (lich@inria.inria.fr).
    Changed by Michael Meissner	(meissner@osf.org).
    64 bit r4000 support by Ian Lance Taylor (ian@cygnus.com) and
@@ -36,9 +36,13 @@
 extern const char *	current_section_name PARAMS ((void));
 extern unsigned int	current_section_flags PARAMS ((void));
 extern int		mips_can_use_return_insn PARAMS ((void));
-extern void		mips_declare_object PARAMS ((FILE *, const char *,
-						     const char *,
-						     const char *, int));
+extern void 		mips_output_aligned_decl_common
+				PARAMS ((FILE *, tree, const char *,
+					 unsigned HOST_WIDE_INT,
+					 unsigned int));
+extern void		mips_declare_object
+				PARAMS ((FILE *, const char *, const char *,
+					 const char *, ...));
 extern void		mips_expand_epilogue PARAMS ((void));
 extern void		mips_expand_prologue PARAMS ((void));
 extern void		mips_output_filename PARAMS ((FILE *, const char *));
Index: gcc/config/mips/mips.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/mips/mips.c,v
retrieving revision 1.241.2.4
retrieving revision 1.241.2.5
diff -u -r1.241.2.4 -r1.241.2.5
--- gcc/gcc/config/mips/mips.c	27 Jun 2003 11:44:23 -0000	1.241.2.4
+++ gcc/gcc/config/mips/mips.c	8 Jan 2005 14:33:33 -0000	1.241.2.5
@@ -1,6 +1,6 @@
 /* Subroutines for insn-output.c for MIPS
    Copyright (C) 1989, 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2005 Free Software Foundation, Inc.
    Contributed by A. Lichnewsky, lich@inria.inria.fr.
    Changes by Michael Meissner, meissner@osf.org.
    64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and
@@ -6562,26 +6562,84 @@
     fatal_io_error ("can't close temp file");
 }
 
-/* Emit either a label, .comm, or .lcomm directive, and mark that the symbol
-   is used, so that we don't emit an .extern for it in mips_asm_file_end.  */
+/* Implement ASM_OUTPUT_ALIGNED_DECL_COMMON.  This is usually the same as
+   the elfos.h version, but we also need to handle -muninit-const-in-rodata
+   and the limitations of the SGI o32 assembler.  */
 
 void
-mips_declare_object (stream, name, init_string, final_string, size)
+mips_output_aligned_decl_common (stream, decl, name, size, align)
      FILE *stream;
+     tree decl;
      const char *name;
-     const char *init_string;
-     const char *final_string;
-     int size;
+     unsigned HOST_WIDE_INT size;
+     unsigned int align;
 {
-  fputs (init_string, stream);		/* "", "\t.comm\t", or "\t.lcomm\t" */
+  const char *format;
+
+  /* If the target wants uninitialized const declarations in
+     .rdata then don't put them in .comm.   */
+  if (TARGET_EMBEDDED_DATA && TARGET_UNINIT_CONST_IN_RODATA
+      && TREE_CODE (decl) == VAR_DECL && TREE_READONLY (decl)
+      && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))
+    {
+      if (TREE_PUBLIC (decl) && DECL_NAME (decl))
+	targetm.asm_out.globalize_label (stream, name);
+
+      readonly_data_section ();
+      ASM_OUTPUT_ALIGN (stream, floor_log2 (align / BITS_PER_UNIT));
+
+      format = ACONCAT ((":\n\t.space\t", HOST_WIDE_INT_PRINT_UNSIGNED,
+			 "\n", NULL));
+      mips_declare_object (stream, name, "", format, size);
+    }
+#ifdef TARGET_IRIX6
+    /* The SGI o32 assembler doesn't accept an alignment, so round up
+       the size instead.  */
+  else if (mips_abi == ABI_32 && !TARGET_GAS)
+    {
+      size += (align / BITS_PER_UNIT) - 1;
+      size -= size % (align / BITS_PER_UNIT);
+      format = ACONCAT ((",", HOST_WIDE_INT_PRINT_UNSIGNED, "\n", NULL));
+      mips_declare_object (stream, name, "\n\t.comm\t", format, size);
+    }
+#endif
+  else
+    {
+      format = ACONCAT ((",", HOST_WIDE_INT_PRINT_UNSIGNED, ",%u\n", NULL));
+      mips_declare_object (stream, name, "\n\t.comm\t", format,
+			   size, align / BITS_PER_UNIT);
+    }
+}
+
+/* Emit either a label, .comm, or .lcomm directive.  When using assembler
+   macros, mark the symbol as written so that mips_file_end won't emit an
+   .extern for it.  STREAM is the output file, NAME is the name of the
+   symbol, INIT_STRING is the string that should be written before the
+   symbol and FINAL_STRING is the string that shoulbe written after it.
+   FINAL_STRING is a printf() format that consumes the remaining arguments.  */
+
+void
+mips_declare_object VPARAMS ((FILE *stream, const char *name,
+			      const char *init_string,
+			      const char *final_string, ...))
+{
+  VA_OPEN (ap, final_string);
+  VA_FIXEDARG (ap, FILE *, stream);
+  VA_FIXEDARG (ap, const char *, name);
+  VA_FIXEDARG (ap, const char *, init_string);
+  VA_FIXEDARG (ap, const char *, final_string);
+
+  fputs (init_string, stream);
   assemble_name (stream, name);
-  fprintf (stream, final_string, size);	/* ":\n", ",%u\n", ",%u\n" */
+  vfprintf (stream, final_string, ap);
 
   if (TARGET_GP_OPT)
     {
       tree name_tree = get_identifier (name);
       TREE_ASM_WRITTEN (name_tree) = 1;
     }
+
+  VA_CLOSE (ap);
 }
 
 /* Return the bytes needed to compute the frame pointer from the current
Index: gcc/config/mips/mips.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/mips/mips.h,v
retrieving revision 1.227.4.6
retrieving revision 1.227.4.7
diff -u -r1.227.4.6 -r1.227.4.7
--- gcc/gcc/config/mips/mips.h	30 May 2003 12:00:42 -0000	1.227.4.6
+++ gcc/gcc/config/mips/mips.h	8 Jan 2005 14:33:34 -0000	1.227.4.7
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler.  MIPS version.
    Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998
-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
    Contributed by A. Lichnewsky (lich@inria.inria.fr).
    Changed by Michael Meissner	(meissner@osf.org).
    64 bit r4000 support by Ian Lance Taylor (ian@cygnus.com) and
@@ -4326,28 +4326,7 @@
 
 /* This says how to define a global common symbol.  */
 
-#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGN) \
-  do {									\
-    /* If the target wants uninitialized const declarations in		\
-       .rdata then don't put them in .comm */				\
-    if (TARGET_EMBEDDED_DATA && TARGET_UNINIT_CONST_IN_RODATA		\
-	&& TREE_CODE (DECL) == VAR_DECL && TREE_READONLY (DECL)		\
-	&& (DECL_INITIAL (DECL) == 0					\
-	    || DECL_INITIAL (DECL) == error_mark_node))			\
-      {									\
-	if (TREE_PUBLIC (DECL) && DECL_NAME (DECL))			\
-	  (*targetm.asm_out.globalize_label) (STREAM, NAME);		\
-	    								\
-	readonly_data_section ();					\
-	ASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));	\
-	mips_declare_object (STREAM, NAME, "", ":\n\t.space\t%u\n",	\
-	    (SIZE));							\
-      }									\
-    else								\
-	mips_declare_object (STREAM, NAME, "\n\t.comm\t", ",%u\n",	\
-	  (SIZE));							\
-  } while (0)
-
+#define ASM_OUTPUT_ALIGNED_DECL_COMMON mips_output_aligned_decl_common
 
 /* This says how to define a local common symbol (ie, not visible to
    linker).  */
Index: gcc/config/mips/mips.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/mips/mips.md,v
retrieving revision 1.153.2.5
retrieving revision 1.153.2.6
diff -u -r1.153.2.5 -r1.153.2.6
--- gcc/gcc/config/mips/mips.md	27 Mar 2004 10:35:03 -0000	1.153.2.5
+++ gcc/gcc/config/mips/mips.md	8 Jan 2005 14:11:12 -0000	1.153.2.6
@@ -1,6 +1,6 @@
 ;;  Mips.md	     Machine Description for MIPS based processors
 ;;  Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-;;  1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+;;  1999, 2000, 2001, 2002, 2005 Free Software Foundation, Inc.
 ;;  Contributed by   A. Lichnewsky, lich@inria.inria.fr
 ;;  Changes by       Michael Meissner, meissner@osf.org
 ;;  64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and
@@ -163,7 +163,8 @@
 
 ;; Describe a user's asm statement.
 (define_asm_attributes
-  [(set_attr "type" "multi")])
+  [(set_attr "type" "multi")
+   (set_attr "can_delay" "no")])
 
 ;; whether or not generating calls to position independent functions
 (define_attr "abicalls" "no,yes"
Index: gcc/config/pa/pa32-linux.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/pa/pa32-linux.h,v
retrieving revision 1.10
retrieving revision 1.10.2.1
diff -u -r1.10 -r1.10.2.1
--- gcc/gcc/config/pa/pa32-linux.h	6 Dec 2002 02:54:38 -0000	1.10
+++ gcc/gcc/config/pa/pa32-linux.h	27 Dec 2004 02:55:49 -0000	1.10.2.1
@@ -28,7 +28,7 @@
    pointer into the frame.  This target does not need multiple
    subspace stubs, so we allow sibcalls to all functions.  */
 #undef FUNCTION_OK_FOR_SIBCALL
-#define FUNCTION_OK_FOR_SIBCALL(DECL) 1
+#define FUNCTION_OK_FOR_SIBCALL(DECL) (!TARGET_PORTABLE_RUNTIME)
 
 /* The libcall __canonicalize_funcptr_for_compare is referenced in
    crtend.o and the reference isn't resolved in objects that don't
Index: gcc/config/rs6000/rs6000.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/rs6000/rs6000.c,v
retrieving revision 1.403.2.14
retrieving revision 1.403.2.16
diff -u -r1.403.2.14 -r1.403.2.16
--- gcc/gcc/config/rs6000/rs6000.c	14 Jan 2004 14:03:58 -0000	1.403.2.14
+++ gcc/gcc/config/rs6000/rs6000.c	1 Dec 2004 06:13:16 -0000	1.403.2.16
@@ -150,7 +150,8 @@
 /* Call distance, overridden by -mlongcall and #pragma longcall(1).
    The only place that looks at this is rs6000_set_default_type_attributes;
    everywhere else should rely on the presence or absence of a longcall
-   attribute on the function declaration.  */
+   attribute on the function declaration.  Exception: init_cumulative_args
+   looks at it too, for libcalls.  */
 int rs6000_default_long_calls;
 const char *rs6000_longcall_switch;
 
@@ -2910,10 +2911,11 @@
   cum->orig_nargs = cum->nargs_prototype;
 
   /* Check for a longcall attribute.  */
-  if (fntype
-      && lookup_attribute ("longcall", TYPE_ATTRIBUTES (fntype))
-      && !lookup_attribute ("shortcall", TYPE_ATTRIBUTES (fntype)))
-    cum->call_cookie = CALL_LONG;
+  if ((!fntype && rs6000_default_long_calls)
+      || (fntype
+	  && lookup_attribute ("longcall", TYPE_ATTRIBUTES (fntype))
+	  && !lookup_attribute ("shortcall", TYPE_ATTRIBUTES (fntype))))
+    cum->call_cookie |= CALL_LONG;
 
   if (TARGET_DEBUG_ARG)
     {
@@ -10356,8 +10358,10 @@
       rtx reg, mem, vrsave;
       int offset;
 
-      /* Get VRSAVE onto a GPR.  */
-      reg = gen_rtx_REG (SImode, 12);
+      /* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12
+	 as frame_reg_rtx and r11 as the static chain pointer for
+	 nested functions.  */
+      reg = gen_rtx_REG (SImode, 0);
       vrsave = gen_rtx_REG (SImode, VRSAVE_REGNO);
       if (TARGET_MACHO)
 	emit_insn (gen_get_vrsave_internal (reg));
Index: gcc/config/rs6000/rs6000.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/rs6000/rs6000.md,v
retrieving revision 1.224.2.6
retrieving revision 1.224.2.7
diff -u -r1.224.2.6 -r1.224.2.7
--- gcc/gcc/config/rs6000/rs6000.md	8 Mar 2004 04:20:45 -0000	1.224.2.6
+++ gcc/gcc/config/rs6000/rs6000.md	24 Dec 2004 23:17:06 -0000	1.224.2.7
@@ -3124,61 +3124,6 @@
 }"
   [(set_attr "length" "8")])
 
-(define_insn_and_split "*andsi3_internal7"
-  [(set (match_operand:CC 2 "cc_reg_operand" "=x,?y")
-	(compare:CC (and:SI (match_operand:SI 0 "gpc_reg_operand" "r,r")
-			    (match_operand:SI 1 "mask_operand_wrap" "i,i"))
-		    (const_int 0)))
-   (clobber (match_scratch:SI 3 "=r,r"))]
-  "TARGET_POWERPC64"
-  "#"
-  "TARGET_POWERPC64"
-  [(parallel [(set (match_dup 2)
-		   (compare:CC (and:SI (rotate:SI (match_dup 0) (match_dup 4))
-				       (match_dup 5))
-			       (const_int 0)))
-	      (clobber (match_dup 3))])]
-  "
-{
-  int mb = extract_MB (operands[1]);
-  int me = extract_ME (operands[1]);
-  operands[4] = GEN_INT (me + 1);
-  operands[5] = GEN_INT (~((HOST_WIDE_INT) -1 << (33 + me - mb)));
-}"
-  [(set_attr "type" "delayed_compare,compare")
-   (set_attr "length" "4,8")])
-
-(define_insn_and_split "*andsi3_internal8"
-  [(set (match_operand:CC 3 "cc_reg_operand" "=x,??y")
-	(compare:CC (and:SI (match_operand:SI 1 "gpc_reg_operand" "r,r")
-			    (match_operand:SI 2 "mask_operand_wrap" "i,i"))
-		    (const_int 0)))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r,r")
-	(and:SI (match_dup 1)
-		(match_dup 2)))]
-  "TARGET_POWERPC64"
-  "#"
-  "TARGET_POWERPC64"
-  [(parallel [(set (match_dup 3)
-		   (compare:CC (and:SI (rotate:SI (match_dup 1) (match_dup 4))
-				       (match_dup 5))
-			       (const_int 0)))
-	      (set (match_dup 0)
-		   (and:SI (rotate:SI (match_dup 1) (match_dup 4))
-			   (match_dup 5)))])
-   (set (match_dup 0)
-	(rotate:SI (match_dup 0) (match_dup 6)))]
-  "
-{
-  int mb = extract_MB (operands[2]);
-  int me = extract_ME (operands[2]);
-  operands[4] = GEN_INT (me + 1);
-  operands[6] = GEN_INT (32 - (me + 1));
-  operands[5] = GEN_INT (~((HOST_WIDE_INT) -1 << (33 + me - mb)));
-}"
-  [(set_attr "type" "delayed_compare,compare")
-   (set_attr "length" "8,12")])
-
 (define_expand "iorsi3"
   [(set (match_operand:SI 0 "gpc_reg_operand" "")
 	(ior:SI (match_operand:SI 1 "gpc_reg_operand" "")
Index: gcc/config/s390/s390.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/s390/s390.md,v
retrieving revision 1.41.2.12
retrieving revision 1.41.2.13
diff -u -r1.41.2.12 -r1.41.2.13
--- gcc/gcc/config/s390/s390.md	3 Aug 2004 20:06:51 -0000	1.41.2.12
+++ gcc/gcc/config/s390/s390.md	27 Jan 2005 23:38:39 -0000	1.41.2.13
@@ -910,11 +910,13 @@
 })
 
 (define_expand "reload_outti"
-  [(parallel [(match_operand:TI 0 "memory_operand" "")
+  [(parallel [(match_operand:TI 0 "" "")
               (match_operand:TI 1 "register_operand" "d")
               (match_operand:DI 2 "register_operand" "=&a")])]
   "TARGET_64BIT"
 {
+  if (GET_CODE (operands[0]) != MEM)
+    abort ();
   s390_load_address (operands[2], XEXP (operands[0], 0));
   operands[0] = replace_equiv_address (operands[0], operands[2]);
   emit_move_insn (operands[0], operands[1]);
@@ -1060,11 +1062,13 @@
 })
 
 (define_expand "reload_outdi"
-  [(parallel [(match_operand:DI 0 "memory_operand" "")
+  [(parallel [(match_operand:DI 0 "" "")
               (match_operand:DI 1 "register_operand" "d")
               (match_operand:SI 2 "register_operand" "=&a")])]
   "!TARGET_64BIT"
 {
+  if (GET_CODE (operands[0]) != MEM)
+    abort ();
   s390_load_address (operands[2], XEXP (operands[0], 0));
   operands[0] = replace_equiv_address (operands[0], operands[2]);
   emit_move_insn (operands[0], operands[1]);
@@ -1374,11 +1378,13 @@
 })
 
 (define_expand "reload_outdf"
-  [(parallel [(match_operand:DF 0 "memory_operand" "")
+  [(parallel [(match_operand:DF 0 "" "")
               (match_operand:DF 1 "register_operand" "d")
               (match_operand:SI 2 "register_operand" "=&a")])]
   "!TARGET_64BIT"
 {
+  if (GET_CODE (operands[0]) != MEM)
+    abort ();
   s390_load_address (operands[2], XEXP (operands[0], 0));
   operands[0] = replace_equiv_address (operands[0], operands[2]);
   emit_move_insn (operands[0], operands[1]);
Index: gcc/config/sparc/sparc.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/sparc/sparc.c,v
retrieving revision 1.233.4.12
retrieving revision 1.233.4.13
diff -u -r1.233.4.12 -r1.233.4.13
--- gcc/gcc/config/sparc/sparc.c	17 Jul 2004 19:49:21 -0000	1.233.4.12
+++ gcc/gcc/config/sparc/sparc.c	14 Oct 2004 06:54:26 -0000	1.233.4.13
@@ -178,6 +178,8 @@
 static void sparc_encode_section_info PARAMS ((tree, int));
 static void sparc_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,
 					   HOST_WIDE_INT, tree));
+static bool sparc_can_output_mi_thunk PARAMS ((tree, HOST_WIDE_INT,
+					       HOST_WIDE_INT, tree));
 
 /* Option handling.  */
 
@@ -244,7 +246,7 @@
 #undef TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK sparc_output_mi_thunk
 #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK sparc_can_output_mi_thunk
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
@@ -8622,18 +8624,21 @@
     SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;
 }
 
-/* Output code to add DELTA to the first argument, and then jump to FUNCTION.
-   Used for C++ multiple inheritance.  */
+/* Output the assembler code for a thunk function.  THUNK_DECL is the
+   declaration for the thunk function itself, FUNCTION is the decl for
+   the target function.  DELTA is an immediate constant offset to be
+   added to THIS.  If VCALL_OFFSET is nonzero, the word at address
+   (*THIS + VCALL_OFFSET) should be additionally added to THIS.  */
 
 static void
 sparc_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)
      FILE *file;
      tree thunk_fndecl ATTRIBUTE_UNUSED;
      HOST_WIDE_INT delta;
-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;
+     HOST_WIDE_INT vcall_offset;
      tree function;
 {
-  rtx this, insn, funexp, delta_rtx, tmp;
+  rtx this, insn, funexp;
 
   reload_completed = 1;
   no_new_pseudos = 1;
@@ -8650,26 +8655,73 @@
 
   /* Add DELTA.  When possible use a plain add, otherwise load it into
      a register first.  */
-  delta_rtx = GEN_INT (delta);
-  if (!SPARC_SIMM13_P (delta))
+  if (delta)
     {
+      rtx delta_rtx = GEN_INT (delta);
+
+      if (! SPARC_SIMM13_P (delta))
+	{
+	  rtx scratch = gen_rtx_REG (Pmode, 1);
+	  emit_move_insn (scratch, delta_rtx);
+	  delta_rtx = scratch;
+	}
+
+      /* THIS += DELTA.  */
+      emit_insn (gen_add2_insn (this, delta_rtx));
+    }
+
+  /* Add the word at address (*THIS + VCALL_OFFSET).  */
+  if (vcall_offset)
+    {
+      rtx vcall_offset_rtx = GEN_INT (vcall_offset);
       rtx scratch = gen_rtx_REG (Pmode, 1);
 
-      if (input_operand (delta_rtx, GET_MODE (scratch)))
-	emit_insn (gen_rtx_SET (VOIDmode, scratch, delta_rtx));
+      if (vcall_offset >= 0)
+	abort ();
+
+      /* SCRATCH = *THIS.  */
+      emit_move_insn (scratch, gen_rtx_MEM (Pmode, this));
+
+      /* Prepare for adding VCALL_OFFSET.  The difficulty is that we
+	 may not have any available scratch register at this point.  */
+      if (SPARC_SIMM13_P (vcall_offset))
+	;
+      /* This is the case if ARCH64 (unless -ffixed-g5 is passed).  */
+      else if (! fixed_regs[5]
+	       /* The below sequence is made up of at least 2 insns,
+		  while the default method may need only one.  */
+	       && vcall_offset < -8192)
+	{
+	  rtx scratch2 = gen_rtx_REG (Pmode, 5);
+	  emit_move_insn (scratch2, vcall_offset_rtx);
+	  vcall_offset_rtx = scratch2;
+	}
       else
 	{
-	  if (TARGET_ARCH64)
-	    sparc_emit_set_const64 (scratch, delta_rtx);
-	  else
-	    sparc_emit_set_const32 (scratch, delta_rtx);
+	  rtx increment = GEN_INT (-4096);
+
+	  /* VCALL_OFFSET is a negative number whose typical range can be
+	     estimated as -32768..0 in 32-bit mode.  In almost all cases
+	     it is therefore cheaper to emit multiple add insns than
+	     spilling and loading the constant into a register (at least
+	     6 insns).  */
+	  while (! SPARC_SIMM13_P (vcall_offset))
+	    {
+	      emit_insn (gen_add2_insn (scratch, increment));
+	      vcall_offset += 4096;
+	    }
+	  vcall_offset_rtx = GEN_INT (vcall_offset); /* cannot be 0 */
 	}
 
-      delta_rtx = scratch;
-    }
+      /* SCRATCH = *(*THIS + VCALL_OFFSET).  */
+      emit_move_insn (scratch, gen_rtx_MEM (Pmode,
+					    gen_rtx_PLUS (Pmode,
+							  scratch,
+							  vcall_offset_rtx)));
 
-  tmp = gen_rtx_PLUS (Pmode, this, delta_rtx);
-  emit_insn (gen_rtx_SET (VOIDmode, this, tmp));
+      /* THIS += *(*THIS + VCALL_OFFSET).  */
+      emit_insn (gen_add2_insn (this, scratch));
+    }
 
   /* Generate a tail call to the target function.  */
   if (! TREE_USED (function))
@@ -8697,4 +8749,18 @@
   no_new_pseudos = 0;
 }
 
+/* Return true if sparc_output_mi_thunk would be able to output the
+   assembler code for the thunk function specified by the arguments
+   it is passed, and false otherwise.  */
+static bool
+sparc_can_output_mi_thunk (thunk_fndecl, delta, vcall_offset, function)
+     tree thunk_fndecl ATTRIBUTE_UNUSED;
+     HOST_WIDE_INT delta ATTRIBUTE_UNUSED;
+     HOST_WIDE_INT vcall_offset;
+     tree function ATTRIBUTE_UNUSED;
+{
+  /* Bound the loop used in the default method above.  */
+  return (vcall_offset >= -32768 || ! fixed_regs[5]);
+}
+
 #include "gt-sparc.h"
Index: gcc/config/sparc/sparc.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/sparc/sparc.md,v
retrieving revision 1.181.4.13
retrieving revision 1.181.4.14
diff -u -r1.181.4.13 -r1.181.4.14
--- gcc/gcc/config/sparc/sparc.md	17 Jul 2004 19:49:21 -0000	1.181.4.13
+++ gcc/gcc/config/sparc/sparc.md	14 Oct 2004 06:54:27 -0000	1.181.4.14
@@ -2048,7 +2048,6 @@
   if (! CONSTANT_P (operands[1]) || input_operand (operands[1], DImode))
     ;
   else if (TARGET_ARCH64
-	   && CONSTANT_P (operands[1])
            && GET_CODE (operands[1]) != HIGH
            && GET_CODE (operands[1]) != LO_SUM)
     {
Index: gcc/config/vax/vax.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/vax/vax.c,v
retrieving revision 1.38
retrieving revision 1.38.4.1
diff -u -r1.38 -r1.38.4.1
--- gcc/gcc/config/vax/vax.c	22 Oct 2002 23:05:24 -0000	1.38
+++ gcc/gcc/config/vax/vax.c	28 Dec 2004 06:29:59 -0000	1.38.4.1
@@ -462,7 +462,7 @@
     case CONST_INT:
       /* byte offsets cost nothing (on a VAX 2, they cost 1 cycle) */
       if (offset == 0)
-	offset = (unsigned)(INTVAL(addr)+128) > 256;
+	offset = (unsigned HOST_WIDE_INT)(INTVAL(addr)+128) > 256;
       break;
     case CONST:
     case SYMBOL_REF:
@@ -595,13 +595,13 @@
 	fmt = "e";	/* all constant rotate counts are short */
       break;
     case PLUS:
-      /* Check for small negative integer operand: subl2 can be used with
-	 a short positive constant instead.  */
-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)
-	if ((unsigned)(INTVAL (XEXP (x, 1)) + 63) < 127)
-	  fmt = "e";
     case MINUS:
       c = (mode == DFmode) ? 13 : 8;	/* 6/8 on VAX 9000, 16/15 on VAX 2 */
+      /* Small integer operands can use subl2 and addl2.  */
+      if ((GET_CODE (XEXP (x, 1)) == CONST_INT)
+	  && (unsigned HOST_WIDE_INT)(INTVAL (XEXP (x, 1)) + 63) < 127)
+	fmt = "e";
+      break;
     case IOR:
     case XOR:
       c = 3;
@@ -611,7 +611,7 @@
       c = 3;
       if (GET_CODE (XEXP (x, 0)) == CONST_INT)
 	{
-	  if ((unsigned)~INTVAL (XEXP (x, 0)) > 63)
+	  if ((unsigned HOST_WIDE_INT)~INTVAL (XEXP (x, 0)) > 63)
 	    c = 4;
 	  fmt = "e";
 	  i = 1;
@@ -665,7 +665,8 @@
       switch (code)
 	{
 	case CONST_INT:
-	  if ((unsigned)INTVAL (op) > 63 && GET_MODE (x) != QImode)
+	  if ((unsigned HOST_WIDE_INT)INTVAL (op) > 63
+	      && GET_MODE (x) != QImode)
 	    c += 1;		/* 2 on VAX 2 */
 	  break;
 	case CONST:
Index: gcc/config/vax/vax.h
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/vax/vax.h,v
retrieving revision 1.54
retrieving revision 1.54.4.1
diff -u -r1.54 -r1.54.4.1
--- gcc/gcc/config/vax/vax.h	22 Oct 2002 23:05:24 -0000	1.54
+++ gcc/gcc/config/vax/vax.h	28 Dec 2004 06:28:01 -0000	1.54.4.1
@@ -800,11 +800,6 @@
    Do not define this if the table should contain absolute addresses.  */
 #define CASE_VECTOR_PC_RELATIVE 1
 
-/* Define this if the case instruction drops through after the table
-   when the index is out of range.  Don't define it if the case insn
-   jumps to the default label instead.  */
-#define CASE_DROPS_THROUGH
-
 /* Indicate that jump tables go in the text section.  This is
    necessary when compiling PIC code.  */
 #define JUMP_TABLES_IN_TEXT_SECTION 1
Index: gcc/config/vax/vax.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/vax/vax.md,v
retrieving revision 1.23
retrieving revision 1.23.4.1
diff -u -r1.23 -r1.23.4.1
--- gcc/gcc/config/vax/vax.md	1 Oct 2002 20:16:04 -0000	1.23
+++ gcc/gcc/config/vax/vax.md	28 Dec 2004 06:28:01 -0000	1.23.4.1
@@ -1969,68 +1969,63 @@
   "jmp (%0)")
 
 ;; This is here to accept 5 arguments (as passed by expand_end_case)
-;; and pass the first 4 along to the casesi1 pattern that really does the work.
+;; and pass the first 4 along to the casesi1 pattern that really does
+;; the actual casesi work.  We emit a jump here to the default label
+;; _before_ the casesi so that we can be sure that the casesi never
+;; drops through.
+;; This is suboptimal perhaps, but so is much of the rest of this
+;; machine description.  For what it's worth, HPPA uses the same trick.
+;;
+;; operand 0 is index
+;; operand 1 is the minimum bound (a const_int)
+;; operand 2 is the maximum bound - minimum bound + 1 (also a const_int)
+;; operand 3 is CODE_LABEL for the table;
+;; operand 4 is the CODE_LABEL to go to if index out of range (ie. default).
+;;
+;; We emit:
+;;	i = index - minimum_bound
+;;	if (i > (maximum_bound - minimum_bound + 1) goto default;
+;;	casesi (i, 0, table);
+;;
 (define_expand "casesi"
-  [(match_operand:SI 0 "general_operand" "")	; index
-   (match_operand:SI 1 "general_operand" "")	; lower
-   (match_operand:SI 2 "general_operand" "")	; upper-lower
-   (match_operand 3 "" "")			; table label
-   (match_operand 4 "" "")]			; default label
-  ""
-{
-  emit_jump_insn (gen_casesi1 (operands[0], operands[1],
-			       operands[2], operands[3]));
+  [(match_operand:SI 0 "general_operand" "")
+   (match_operand:SI 1 "general_operand" "")
+   (match_operand:SI 2 "general_operand" "")
+   (match_operand 3 "" "")
+   (match_operand 4 "" "")]
+  ""
+{
+  /* i = index - minimum_bound;
+     But only if the lower bound is not already zero.  */
+  if (operands[1] != const0_rtx)
+    {
+      rtx index = gen_reg_rtx (SImode);
+      emit_insn (gen_addsi3 (index,
+			     operands[0],
+			     GEN_INT (-INTVAL (operands[1]))));
+      operands[0] = index;
+    }
+
+  /* if (i > (maximum_bound - minimum_bound + 1) goto default;  */
+  emit_insn (gen_cmpsi (operands[0], operands[2]));
+  emit_jump_insn (gen_bgtu (operands[4]));
+
+  /* casesi (i, 0, table);  */
+  emit_jump_insn (gen_casesi1 (operands[0], operands[2], operands[3]));
   DONE;
 })
 
+;; This insn is a bit of a lier.  It actually falls through if no case
+;; matches.  But, we prevent that from ever happening by emiting a jump
+;; before this, see the define_expand above.
 (define_insn "casesi1"
-  [(set (pc)
-	(if_then_else
-	 (leu (minus:SI (match_operand:SI 0 "general_operand" "g")
-			(match_operand:SI 1 "general_operand" "g"))
-	      (match_operand:SI 2 "general_operand" "g"))
-	 (plus:SI (sign_extend:SI
-		   (mem:HI (plus:SI (mult:SI (minus:SI (match_dup 0)
-						       (match_dup 1))
-					     (const_int 2))
-				    (pc))))
-		  (label_ref:SI (match_operand 3 "" "")))
-	 (pc)))]
-  ""
-  "casel %0,%1,%2")
-
-;; This can arise by simplification when operand 1 is a constant int.
-(define_insn ""
-  [(set (pc)
-	(if_then_else
-	 (leu (plus:SI (match_operand:SI 0 "general_operand" "g")
-		       (match_operand:SI 1 "const_int_operand" "n"))
-	      (match_operand:SI 2 "general_operand" "g"))
-	 (plus:SI (sign_extend:SI
-		   (mem:HI (plus:SI (mult:SI (plus:SI (match_dup 0)
-						      (match_dup 1))
-					     (const_int 2))
-				    (pc))))
-		  (label_ref:SI (match_operand 3 "" "")))
-	 (pc)))]
-  ""
-  "*
-{
-  operands[1] = GEN_INT (-INTVAL (operands[1]));
-  return \"casel %0,%1,%2\";
-}")
-
-;; This can arise by simplification when the base for the case insn is zero.
-(define_insn ""
-  [(set (pc)
-	(if_then_else (leu (match_operand:SI 0 "general_operand" "g")
-			   (match_operand:SI 1 "general_operand" "g"))
-		      (plus:SI (sign_extend:SI
-				(mem:HI (plus:SI (mult:SI (match_dup 0)
-							  (const_int 2))
-					(pc))))
-			       (label_ref:SI (match_operand 2 "" "")))
-		      (pc)))]
+  [(match_operand:SI 1 "const_int_operand" "n")
+   (set (pc)
+	(plus:SI (sign_extend:SI
+		  (mem:HI (plus:SI (mult:SI (match_operand:SI 0 "general_operand" "g")
+					    (const_int 2))
+			  (pc))))
+		 (label_ref:SI (match_operand 2 "" ""))))]
   ""
   "casel %0,$0,%1")
 
Index: gcc/cp/ChangeLog
===================================================================
RCS file: /cvs/gcc/gcc/gcc/cp/ChangeLog,v
retrieving revision 1.3076.2.277
retrieving revision 1.3076.2.281
diff -u -r1.3076.2.277 -r1.3076.2.281
--- gcc/gcc/cp/ChangeLog	30 Sep 2004 16:44:00 -0000	1.3076.2.277
+++ gcc/gcc/cp/ChangeLog	18 Dec 2004 20:26:04 -0000	1.3076.2.281
@@ -1,3 +1,25 @@
+2004-12-18  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>
+
+	PR c++/17456
+	* cvt.c (convert_to_void): Set expr to void_zero_node after
+	overload failure.
+
+2004-12-15  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>
+
+	PR c++/16806
+	* error.c (dump_expr) [BASELINK]: Use dump_expr.
+
+2004-12-10  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>
+
+	PR c++/17868
+	* error.c (dump_expr): Add missing case for RDIV_EXPR.
+
+2004-12-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	PR c++/16681
+	* init.c (build_zero_init): Build a RANGE_EXPR for an array
+	initializer.
+
 2004-09-30  Release Manager
 
 	* GCC 3.3.5 Released.
Index: gcc/cp/cvt.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/cp/cvt.c,v
retrieving revision 1.126.2.4
retrieving revision 1.126.2.5
diff -u -r1.126.2.4 -r1.126.2.5
--- gcc/gcc/cp/cvt.c	23 Feb 2004 12:50:50 -0000	1.126.2.4
+++ gcc/gcc/cp/cvt.c	18 Dec 2004 20:26:10 -0000	1.126.2.5
@@ -903,6 +903,7 @@
 	   of an overloaded function, and this is not one of them.  */
 	pedwarn ("%s cannot resolve address of overloaded function",
 		    implicit ? implicit : "void cast");
+	expr = void_zero_node;
       }
     else if (implicit && probe == expr && is_overloaded_fn (probe))
       /* Only warn when there is no &.  */
Index: gcc/cp/error.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/cp/error.c,v
retrieving revision 1.192.2.9
retrieving revision 1.192.2.11
diff -u -r1.192.2.9 -r1.192.2.11
--- gcc/gcc/cp/error.c	24 Jul 2004 13:03:23 -0000	1.192.2.9
+++ gcc/gcc/cp/error.c	15 Dec 2004 16:45:23 -0000	1.192.2.11
@@ -1724,6 +1724,7 @@
     case CEIL_DIV_EXPR:
     case FLOOR_DIV_EXPR:
     case ROUND_DIV_EXPR:
+    case RDIV_EXPR:
       dump_binary_op ("/", t, flags);
       break;
 
@@ -2070,7 +2071,7 @@
       break;
 
     case BASELINK:
-      print_tree_identifier (scratch_buffer, DECL_NAME (get_first_fn (t)));
+      dump_expr (get_first_fn (t), flags & ~TFF_EXPR_IN_PARENS);
       break;
 
     case TREE_LIST:
Index: gcc/cp/init.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/cp/init.c,v
retrieving revision 1.299.2.18
retrieving revision 1.299.2.19
diff -u -r1.299.2.18 -r1.299.2.19
--- gcc/gcc/cp/init.c	28 Jul 2004 02:17:28 -0000	1.299.2.18
+++ gcc/gcc/cp/init.c	9 Dec 2004 15:09:19 -0000	1.299.2.19
@@ -235,7 +235,6 @@
     }
   else if (TREE_CODE (type) == ARRAY_TYPE)
     {
-      tree index;
       tree max_index;
       tree inits;
 
@@ -249,15 +248,17 @@
       /* A zero-sized array, which is accepted as an extension, will
          have an upper bound of -1.  */
       if (!tree_int_cst_equal (max_index, integer_minus_one_node))
-        for (index = size_zero_node;
-             !tree_int_cst_lt (max_index, index);
-             index = size_binop (PLUS_EXPR, index, size_one_node))
-          inits = tree_cons (index,
-                             build_zero_init (TREE_TYPE (type),
-                                              /*nelts=*/NULL_TREE,
-                                              static_storage_p),
-                             inits);
-         CONSTRUCTOR_ELTS (init) = nreverse (inits);
+ 	{
+ 	  tree elt_init = build_zero_init (TREE_TYPE (type),
+ 					   /*nelts=*/NULL_TREE,
+ 					   static_storage_p);
+ 	  tree range = build (RANGE_EXPR,
+			      sizetype, size_zero_node, max_index);
+ 	  
+ 	  inits = tree_cons (range, elt_init, inits);
+ 	}
+       
+      CONSTRUCTOR_ELTS (init) = nreverse (inits);
     }
   else if (TREE_CODE (type) == REFERENCE_TYPE)
     ;
Index: gcc/doc/install.texi
===================================================================
RCS file: /cvs/gcc/gcc/gcc/doc/install.texi,v
retrieving revision 1.151.2.53
retrieving revision 1.151.2.56
diff -u -r1.151.2.53 -r1.151.2.56
--- gcc/gcc/doc/install.texi	8 May 2004 17:37:31 -0000	1.151.2.53
+++ gcc/gcc/doc/install.texi	14 Oct 2004 12:31:38 -0000	1.151.2.56
@@ -3098,8 +3098,19 @@
 @file{/usr/bin} before @file{/usr/xpg4/bin} for the duration of the build.
 
 All releases of GNU binutils prior to 2.11.2 have known bugs on this
-platform.  We recommend the use of GNU binutils 2.11.2 or the vendor
-tools (Sun @command{as}, Sun @command{ld}).
+platform.  We recommend the use of GNU binutils 2.11.2 or later, or the
+vendor tools (Sun @command{as}, Sun @command{ld}).  Note that your mileage
+may vary if you use a combination of the GNU tools and the Sun tools: while
+the combination GNU @command{as} + Sun @command{ld} should reasonably work,
+the reverse combination Sun @command{as} + GNU @command{ld} is known to
+cause memory corruption at runtime in some cases for C++ programs.
+
+The stock GNU binutils 2.15 release is broken on this platform because of a
+single bug.  It has been fixed on the 2.15 branch in the CVS repository.
+You can obtain a working version by checking out the binutils-2_15-branch
+from the CVS repository or applying the patch
+@uref{http://sources.redhat.com/ml/binutils-cvs/2004-09/msg00036.html} to the
+release.
 
 Sun bug 4296832 turns up when compiling X11 headers with GCC 2.95 or
 newer: @command{g++} will complain that types are missing.  These headers assume
@@ -3115,6 +3126,17 @@
 108377-20 for Intel), and Solaris 8 (108652-24 or newer for SPARC,
 108653-22 for Intel) that fix this bug.
 
+Sun bug 4927647 sometimes causes random spurious testsuite failures
+related to missing diagnostic output.  This bug doesn't affect GCC
+itself, rather it is a kernel bug triggered by the @command{expect}
+program which is used only by the GCC testsuite driver.  When the bug
+causes the @command{expect} program to miss anticipated output, extra
+testsuite failures appear.
+
+There are patches for Solaris 8 (117350-12 or newer for SPARC,
+117351-12 or newer for Intel) and Solaris 9 (117171-11 or newer for
+SPARC, 117172-11 or newer for Intel) that address this problem.
+
 @html
 <hr />
 @end html
Index: gcc/doc/tm.texi
===================================================================
RCS file: /cvs/gcc/gcc/gcc/doc/tm.texi,v
retrieving revision 1.182.2.8
retrieving revision 1.182.2.9
diff -u -r1.182.2.8 -r1.182.2.9
--- gcc/gcc/doc/tm.texi	5 Mar 2004 17:55:57 -0000	1.182.2.8
+++ gcc/gcc/doc/tm.texi	14 Oct 2004 06:54:32 -0000	1.182.2.9
@@ -4160,7 +4160,7 @@
 @end table
 
 @findex TARGET_ASM_OUTPUT_MI_THUNK
-@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_MI_THUNK (FILE *@var{file}, tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, tree @var{function})
+@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_MI_THUNK (FILE *@var{file}, tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, tree @var{function})
 A function that outputs the assembler code for a thunk
 function, used to implement C++ virtual function calls with multiple
 inheritance.  The thunk acts as a wrapper around a virtual function,
@@ -4174,7 +4174,15 @@
 e.g.@: @samp{%o0} on a sparc.  The addition must preserve the values of
 all other incoming arguments.
 
-After the addition, emit code to jump to @var{function}, which is a
+Then, if @var{vcall_offset} is nonzero, an additional adjustment should be
+made after adding @code{delta}.  In particular, if @var{p} is the
+adjusted pointer, the following adjustment should be made:
+
+@smallexample
+p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]
+@end smallexample
+
+After the additions, emit code to jump to @var{function}, which is a
 @code{FUNCTION_DECL}.  This is a direct pure jump, not a call, and does
 not touch the return address.  Hence returning from @var{FUNCTION} will
 return to whoever called the current @samp{thunk}.
@@ -4194,21 +4202,13 @@
 not support varargs.
 @end deftypefn
 
-@findex TARGET_ASM_OUTPUT_MI_VCALL_THUNK
-@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_MI_VCALL_THUNK (FILE *@var{file}, tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, int @var{vcall_offset}, tree @var{function})
-A function like @code{TARGET_ASM_OUTPUT_MI_THUNK}, except that if
-@var{vcall_offset} is nonzero, an additional adjustment should be made
-after adding @code{delta}.  In particular, if @var{p} is the
-adjusted pointer, the following adjustment should be made:
-
-@example
-p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]
-@end example
-
-@noindent
-If this function is defined, it will always be used in place of
-@code{TARGET_ASM_OUTPUT_MI_THUNK}.
-
+@findex TARGET_ASM_CAN_OUTPUT_MI_THUNK
+@deftypefn {Target Hook} bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (tree @var{thunk_fndecl}, HOST_WIDE_INT @var{delta}, HOST_WIDE_INT @var{vcall_offset}, tree @var{function})
+A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be able
+to output the assembler code for the thunk function specified by the
+arguments it is passed, and false otherwise.  In the latter case, the
+generic approach will be used by the C++ front end, with the limitations
+previously exposed.
 @end deftypefn
 
 @node Profiling
Index: gcc/testsuite/ChangeLog
===================================================================
RCS file: /cvs/gcc/gcc/gcc/testsuite/ChangeLog,v
retrieving revision 1.2261.2.384
retrieving revision 1.2261.2.398
diff -u -r1.2261.2.384 -r1.2261.2.398
--- gcc/gcc/testsuite/ChangeLog	30 Sep 2004 16:45:41 -0000	1.2261.2.384
+++ gcc/gcc/testsuite/ChangeLog	23 Jan 2005 05:16:05 -0000	1.2261.2.398
@@ -1,3 +1,78 @@
+2005-01-22  Roger Sayle  <roger@eyesopen.com>
+
+	PR target/18402
+	Backport from mainline
+	2003-02-05  Jakub Jelinek  <jakub@redhat.com>
+ 
+ 	PR optimization/8555
+	* gcc.dg/20030204-1.c: New test.
+
+2005-01-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>
+
+	PR c++/17115
+	* g++.dg/warn/Winline-4.C: New test.
+
+2005-01-18  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.dg/short-compare-1.c: New test.
+	* gcc.dg/short-compare-2.c: Likewise.
+
+2005-01-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2003-10-13  Geoffrey Keating  <geoffk@apple.com>
+
+	* gcc.dg/asm-names.c: Use scan-assembler-not rather
+	than linker trickery.
+
+2005-01-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.c-torture/execute/20020720-1.x: XFAIL for x86 when using
+	-fpic or -fPIC.
+
+2004-12-21  Joseph S. Myers  <jsm@polyomino.org.uk>
+
+	PR c/14765
+	* gcc.dg/pr14765-1.c: New test.
+
+2004-12-20  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR other/19093
+	* g++.dg/opt/max1.C: Fix for 64bit targets.
+
+2004-12-19  Roger Sayle  <roger@eyesopen.com>
+
+	PR middle-end/19068
+	* g++.dg/opt/max1.C: New test case.
+
+2004-12-16  Wolfgang Bangerth  <bangerth@dealii.com>
+
+	* g++.dg/other/complex1.C: New test.
+
+2004-12-10  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>
+
+	PR rtl-optimization/16536
+	* gcc.c-torture/execute/restrict-1.c: New test.
+
+2004-12-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	PR c++/16681
+	* g++.dg/init/array15.C: New.
+	* g++.dg/init/array16.C: New.
+
+2004-11-29  Roger Sayle  <roger@eyesopen.com>
+
+	PR rtl-optimization/9771
+	* gcc.dg/pr9771-1.c: New test case.
+
+2004-11-27  Falk Hueffner  <falk@debian.org>
+
+	* gcc.dg/loop-6.c: New test.
+
+2004-10-13  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* g++.dg/inherit/thunk1.C: Run on the SPARC.
+
 2004-09-30  Release Manager
 
 	* GCC 3.3.5 Released.
Index: gcc/testsuite/g++.dg/inherit/thunk1.C
===================================================================
RCS file: /cvs/gcc/gcc/gcc/testsuite/g++.dg/inherit/thunk1.C,v
retrieving revision 1.5
retrieving revision 1.5.12.1
diff -u -r1.5 -r1.5.12.1
--- gcc/gcc/testsuite/g++.dg/inherit/thunk1.C	24 Oct 2002 09:16:36 -0000	1.5
+++ gcc/gcc/testsuite/g++.dg/inherit/thunk1.C	14 Oct 2004 06:54:49 -0000	1.5.12.1
@@ -1,4 +1,4 @@
-// { dg-do run { target i?86-*-* x86_64-*-* s390*-*-* alpha*-*-* ia64-*-* } }
+// { dg-do run { target i?86-*-* x86_64-*-* s390*-*-* alpha*-*-* ia64-*-* sparc*-*-* } }
 
 #include <stdarg.h>
 
Index: gcc/testsuite/g++.dg/init/array15.C
===================================================================
RCS file: gcc/testsuite/g++.dg/init/array15.C
diff -N gcc/testsuite/g++.dg/init/array15.C
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/g++.dg/init/array15.C	9 Dec 2004 15:09:32 -0000	1.1.6.1
@@ -0,0 +1,46 @@
+// { dg-do run }
+
+// Copyright (C) 2004 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 8 Dec 2004 <nathan@codesourcery.com>
+
+// PR 16681 too much memory used
+// Origin:  Matt LaFary <lafary@activmedia.com>
+
+struct foo {
+  unsigned char buffer[4111222];
+  foo() ;
+  bool check () const;
+};
+
+foo::foo ()
+  : buffer()
+{}
+
+bool foo::check () const
+{
+  for (unsigned ix = sizeof (buffer); ix--;)
+    if (buffer[ix])
+      return false;
+  return true;
+}
+
+void *operator new (__SIZE_TYPE__ size, void *p)
+{
+  return p;
+}
+
+char heap[5000000];
+
+int main ()
+{
+  for (unsigned ix = sizeof (heap); ix--;)
+    heap[ix] = ix;
+  
+  foo *f = new (heap) foo ();
+
+  if (!f->check ())
+    return 1;
+  return 0;
+}
+
+  
Index: gcc/testsuite/g++.dg/init/array16.C
===================================================================
RCS file: gcc/testsuite/g++.dg/init/array16.C
diff -N gcc/testsuite/g++.dg/init/array16.C
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/g++.dg/init/array16.C	9 Dec 2004 15:09:32 -0000	1.1.6.1
@@ -0,0 +1,106 @@
+// { dg-do run }
+
+// Copyright (C) 2004 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 8 Dec 2004 <nathan@codesourcery.com>
+
+// PR 16681 too much memory used
+// Origin:  Matt LaFary <lafary@activmedia.com>
+
+
+struct elt 
+{
+  static int count;
+  static elt*ptr;
+  static int abort;
+  char c;
+  
+  elt ();
+  ~elt ();
+  
+};
+
+int elt::count;
+elt *elt::ptr;
+int elt::abort;
+
+elt::elt ()
+  :c ()
+{
+  if (count >= 0)
+    {
+      if (!ptr)
+	ptr = this;
+      if (count == 100)
+	throw 2;
+      if (this != ptr)
+	abort = 1;
+      count++;
+      ptr++;
+    }
+}
+
+elt::~elt ()
+{
+  if (count >= 0)
+    {
+      ptr--;
+      count--;
+      if (ptr != this)
+	abort = 2;
+    }
+}
+
+struct foo {
+  elt buffer[4111222];
+  foo() ;
+  bool check () const;
+};
+
+foo::foo ()
+  : buffer()
+{}
+
+bool foo::check () const
+{
+  for (unsigned ix = sizeof (buffer)/ sizeof (buffer[0]); ix--;)
+    if (buffer[ix].c)
+      return false;
+  return true;
+}
+
+void *operator new (__SIZE_TYPE__ size, void *p)
+{
+  return p;
+}
+
+char heap[5000000];
+
+int main ()
+{
+  for (unsigned ix = sizeof (heap); ix--;)
+    heap[ix] = ix;
+
+  try
+    {
+      foo *f = new (heap) foo ();
+      return 1;
+    }
+  catch (...)
+    {
+      if (elt::count)
+	return 2;
+      if (elt::abort)
+	return elt::abort + 3;
+    }
+
+  for (unsigned ix = sizeof (heap); ix--;)
+    heap[ix] = ix;
+
+  elt::count = -1;
+  foo *f = new (heap) foo ();
+  if (!f->check ())
+    return 3;
+  return 0;
+}
+
+  
Index: gcc/testsuite/g++.dg/opt/max1.C
===================================================================
RCS file: gcc/testsuite/g++.dg/opt/max1.C
diff -N gcc/testsuite/g++.dg/opt/max1.C
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/g++.dg/opt/max1.C	20 Dec 2004 21:12:34 -0000	1.2.2.2
@@ -0,0 +1,29 @@
+/* PR middle-end/19068 */
+/* Test case by Andrew Pinski <pinskia@physics.uc.edu> */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern "C" void abort (void);
+
+long fff[10];
+
+void f(long a)
+{
+  int i;
+  a =  *((long*)(a+1+sizeof(long))) >? *((long*)(a+1)); 
+
+  for(i=0;i<10;i++)
+   fff[i] = a;
+}
+
+int main(void)
+{
+  int i;
+  long a[2] = {10,5};
+  f((long)(&a)-1);
+  for(i = 0;i<10;i++)
+   if (fff[i]!=10)
+    abort ();
+  return 0;
+}
+
Index: gcc/testsuite/g++.dg/other/complex1.C
===================================================================
RCS file: gcc/testsuite/g++.dg/other/complex1.C
diff -N gcc/testsuite/g++.dg/other/complex1.C
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/g++.dg/other/complex1.C	16 Dec 2004 14:04:52 -0000	1.1.4.1
@@ -0,0 +1,28 @@
+// PR middle-end/18882
+// Origin: Petr Mikulik <mikulik@physics.muni.cz>
+// Testcase by Wolfgang Bangerth <bangerth@dealii.com>
+
+// { dg-do run }
+// { dg-options "" }
+
+extern "C" void abort ();
+
+struct C {
+  __complex__ long double c; 
+};
+
+void foo()
+{ 
+  C x = {2+2i}; 
+
+  int n = 1; 
+  C y = (n==1) ? x : (C){3+3i}; 
+  if (__imag__ y.c != 2) 
+    abort (); 
+}
+
+int main(void)
+{
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/warn/Winline-4.C
===================================================================
RCS file: gcc/testsuite/g++.dg/warn/Winline-4.C
diff -N gcc/testsuite/g++.dg/warn/Winline-4.C
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/g++.dg/warn/Winline-4.C	21 Jan 2005 10:02:30 -0000	1.1.42.1
@@ -0,0 +1,17 @@
+// { dg-do compile }
+// { dg-options "-O2 -Winline" }
+// Origin: <markus at oberhumer dot com>
+// PR 17115: We should not emit -Winline warning for functions marked with
+//  noinline
+
+struct Foo {
+  __attribute__((noinline)) int a(int r) { return r & 1; }
+  virtual __attribute__((noinline)) int b(int r) { return r & 1; }
+  static  __attribute__((noinline)) int c(int r) { return r & 1; }
+};
+
+int bar(int r) {
+  Foo f;
+  int k = 1; k &= f.a(r); k &= f.b(r); k &= f.a(r);
+  return k;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20020720-1.x
===================================================================
RCS file: /cvs/gcc/gcc/gcc/testsuite/gcc.c-torture/execute/20020720-1.x,v
retrieving revision 1.8.6.2
retrieving revision 1.8.6.3
diff -u -r1.8.6.2 -r1.8.6.3
--- gcc/gcc/testsuite/gcc.c-torture/execute/20020720-1.x	8 Mar 2003 14:34:06 -0000	1.8.6.2
+++ gcc/gcc/testsuite/gcc.c-torture/execute/20020720-1.x	3 Jan 2005 01:43:45 -0000	1.8.6.3
@@ -11,6 +11,19 @@
 #     and can make the optimization.
 
 # Don't XFAIL at -O0, that should never fail.
+if { [istarget "i?86-*-*"] } {
+    set torture_eval_before_compile {
+        global compiler_conditional_xfail_data
+        set compiler_conditional_xfail_data {
+            "PR opt/10348" \
+            { "*-*-*" } \
+            { "-fpic" "-fPIC" } \
+            { "-O0" }
+        }
+    }
+    return 0
+}
+
 set torture_eval_before_compile {
     global compiler_conditional_xfail_data
     set compiler_conditional_xfail_data {
Index: gcc/testsuite/gcc.c-torture/execute/restrict-1.c
===================================================================
RCS file: gcc/testsuite/gcc.c-torture/execute/restrict-1.c
diff -N gcc/testsuite/gcc.c-torture/execute/restrict-1.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.c-torture/execute/restrict-1.c	10 Dec 2004 17:25:07 -0000	1.2.44.1
@@ -0,0 +1,30 @@
+/*  PR rtl-optimization/16536
+    Origin:  Jeremy Denise      <jeremy.denise@libertysurf.fr>
+    Reduced: Wolfgang Bangerth  <bangerth@dealii.org>
+             Volker Reichelt    <reichelt@igpm.rwth-aachen.de>  */
+
+extern void abort ();
+
+typedef struct
+{
+  int i, dummy;
+} A;
+
+inline A foo (const A* p, const A* q)
+{
+  return (A){p->i+q->i};
+}
+
+void bar (A* __restrict__ p)
+{
+  *p=foo(p,p);
+  if (p->i!=2)
+    abort();
+}
+
+int main ()
+{
+  A a={1};
+  bar(&a);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/20030204-1.c
===================================================================
RCS file: gcc/testsuite/gcc.dg/20030204-1.c
diff -N gcc/testsuite/gcc.dg/20030204-1.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.dg/20030204-1.c	23 Jan 2005 05:16:14 -0000	1.3.6.1
@@ -0,0 +1,16 @@
+/* PR optimization/8555 */
+/* { dg-do compile } */
+/* { dg-options "-O -ffast-math -funroll-loops" } */
+/* { dg-options "-march=pentium3 -O -ffast-math -funroll-loops" { target i?86-*-* } } */
+
+float foo (float *a, int i)
+{
+  int j;
+  float x = a[j = i - 1], y;
+
+  for (j = i; --j >= 0; )
+    if ((y = a[j]) > x)
+      x = y;
+
+  return x;
+}
Index: gcc/testsuite/gcc.dg/asm-names.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/testsuite/gcc.dg/asm-names.c,v
retrieving revision 1.2
retrieving revision 1.2.44.1
diff -u -r1.2 -r1.2.44.1
--- gcc/gcc/testsuite/gcc.dg/asm-names.c	27 Aug 2001 19:23:11 -0000	1.2
+++ gcc/gcc/testsuite/gcc.dg/asm-names.c	4 Jan 2005 00:20:35 -0000	1.2.44.1
@@ -2,26 +2,15 @@
    to have an underscore prefixed, even if normal symbols are.
    Problem reported by Krister Walfridsson <cato@df.lth.se>.  */
 
-/* { dg-do link } */
+/* { dg-do compile } */
 /* { dg-options "-fleading-underscore" } */
+/* { dg-final { scan-assembler-not "____frob14" } } */
 
 extern void frobnicate (void) asm ("___frob14");  /* three underscores */
 
-void __frob14 (void) {} /* two underscores */
-
 int
 main (void)
 {
   frobnicate ();
   return 0;
 }
-
-/* In case built where the runtime expects no leading underscore on
-   main(). */
-extern int xmain (void) asm ("main");
-
-int xmain (void) { return main(); }
-
-/* In case built where the runtime calls __main.  */
-extern int ymain (void) asm ("___main");
-int ymain (void) { return main(); }
Index: gcc/testsuite/gcc.dg/loop-6.c
===================================================================
RCS file: gcc/testsuite/gcc.dg/loop-6.c
diff -N gcc/testsuite/gcc.dg/loop-6.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.dg/loop-6.c	27 Nov 2004 16:59:16 -0000	1.1.4.1
@@ -0,0 +1,25 @@
+/* PR optimization/18577 */
+/* Origin: Falk Hueffner <falk@debian.org> */
+
+/* { dg-do run } */
+/* { dg-options "-O2 -funroll-all-loops" } */
+
+static float tfcos12[3];
+__attribute__((noinline)) double f(double x) { return x; }
+int g;
+
+int main(void)
+{
+  int i, j;
+  for (i = 0; i < 1; i++) 
+    tfcos12[i] = 0.5;
+    
+  for (i = 0; i < 1; i++)
+    {
+      tfcos12[i] = 0.5 * f(i);
+      for (j = 0; j < 12; j++)
+	g++;
+    }
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr14765-1.c
===================================================================
RCS file: gcc/testsuite/gcc.dg/pr14765-1.c
diff -N gcc/testsuite/gcc.dg/pr14765-1.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.dg/pr14765-1.c	21 Dec 2004 21:51:29 -0000	1.1.48.1
@@ -0,0 +1,11 @@
+/* Empty statement expressions should get void type.  Bug 14765 from
+   Serge Belyshev <belyshev@lubercy.com>.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+int a;
+void fun ()
+{
+	a = 0;
+	a = ({}); /* { dg-error "not ignored" "void stmt expr" } */
+}
Index: gcc/testsuite/gcc.dg/pr9771-1.c
===================================================================
RCS file: gcc/testsuite/gcc.dg/pr9771-1.c
diff -N gcc/testsuite/gcc.dg/pr9771-1.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.dg/pr9771-1.c	30 Nov 2004 04:34:21 -0000	1.1.44.1
@@ -0,0 +1,43 @@
+/* PR rtl-optimization/9771 */
+/* { dg-do run { target i?86-*-* } } */
+/* { dg-options "-O2 -fomit-frame-pointer -ffixed-ebp" } */
+
+extern void abort(void);
+extern void exit(int);
+
+register long *B asm ("ebp");
+
+long x = 10;
+long y = 20;
+
+void bar(void)
+{
+  B = &y;
+}
+
+void foo()
+{
+  long *adr = B;
+  long save = *adr;
+
+  *adr = 123;
+
+  bar();
+
+  *adr = save;
+}
+
+int main()
+{
+  B = &x;
+
+  foo();
+
+  if (x != 10 || y != 20)
+    abort();
+
+  /* We can't return, as our caller may assume %ebp is preserved!  */
+  /* We could save/restore it (like foo), but its easier to exit.  */
+  exit(0);
+}
+
Index: gcc/testsuite/gcc.dg/short-compare-1.c
===================================================================
RCS file: gcc/testsuite/gcc.dg/short-compare-1.c
diff -N gcc/testsuite/gcc.dg/short-compare-1.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.dg/short-compare-1.c	18 Jan 2005 08:39:29 -0000	1.1.4.1
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/19296 */
+/* Origin: Falk Hueffner <falk@debian.org> */
+
+/* { dg-do run } */
+/* { dg-options "-O" } */
+/* { dg-options "-O -mcpu=i686" { target i?86-*-* } } */
+/* { dg-options "-O -m32 -mcpu=i686" { target x86_64-*-* } } */
+
+extern void abort(void);
+
+void f(unsigned short ad)
+{
+  if (ad >= 0x4000 && ad < 0xc000) 
+    abort();
+}
+
+int main(void)
+{
+  f(0xff00); 
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/short-compare-2.c
===================================================================
RCS file: gcc/testsuite/gcc.dg/short-compare-2.c
diff -N gcc/testsuite/gcc.dg/short-compare-2.c
--- gcc//dev/null	1 Jan 1970 00:00:00 -0000
+++ gcc/gcc/testsuite/gcc.dg/short-compare-2.c	18 Jan 2005 08:39:29 -0000	1.1.4.1
@@ -0,0 +1,22 @@
+/* PR rtl-optimization/19296 */
+/* Origin: Falk Hueffner <falk@debian.org> */
+/* Testcase by Andrew Pinski <pinskia@gcc.gnu.org> */
+
+/* { dg-do run } */
+/* { dg-options "-O" } */
+/* { dg-options "-O -mcpu=i686" { target i?86-*-* } } */
+/* { dg-options "-O -m32 -mcpu=i686" { target x86_64-*-* } } */
+
+extern void abort();
+
+void f(unsigned short ad)
+{
+  if ((short) (ad - 0x4000) >= 0)
+    abort();
+}
+
+int main(void)
+{
+  f(0xc000);
+  return 0;
+}
Index: libstdc++-v3/ChangeLog
===================================================================
RCS file: /cvs/gcc/gcc/libstdc++-v3/ChangeLog,v
retrieving revision 1.1464.2.192
retrieving revision 1.1464.2.195
diff -u -r1.1464.2.192 -r1.1464.2.195
--- gcc/libstdc++-v3/ChangeLog	30 Sep 2004 16:47:23 -0000	1.1464.2.192
+++ gcc/libstdc++-v3/ChangeLog	21 Jan 2005 23:52:45 -0000	1.1464.2.195
@@ -1,3 +1,18 @@
+2005-01-22  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>
+
+	PR libstdc++/19510
+	* include/bits/stl_list.h (_List_iterator_base): Initialize _M_node
+	in constructor.
+	(_List_iterator): Initialize _List_iterator_base in constructor.
+	* include/bits/stl_tree.h (_Rb_tree_iterator): Initialize _M_node
+	in constructor.
+
+2004-12-03  Richard Henderson  <rth@redhat.com>
+
+	PR 17856
+	* config/cpu/i486/atomicity.h (__exchange_and_add, __atomic_add):
+	Split in-out memory constraints.
+
 2004-09-30  Release Manager
 
 	* GCC 3.3.5 Released.
Index: libstdc++-v3/config/cpu/i486/atomicity.h
===================================================================
RCS file: /cvs/gcc/gcc/libstdc++-v3/config/cpu/i486/atomicity.h,v
retrieving revision 1.1.22.1
retrieving revision 1.1.22.2
diff -u -r1.1.22.1 -r1.1.22.2
--- gcc/libstdc++-v3/config/cpu/i486/atomicity.h	2 Jun 2003 18:48:52 -0000	1.1.22.1
+++ gcc/libstdc++-v3/config/cpu/i486/atomicity.h	3 Dec 2004 23:44:07 -0000	1.1.22.2
@@ -1,6 +1,6 @@
 // Low-level functions for atomic operations: x86, x >= 4 version  -*- C++ -*-
 
-// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+// Copyright (C) 1999, 2000, 2001, 2004 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -38,8 +38,8 @@
 {
   register _Atomic_word __result;
   __asm__ __volatile__ ("lock; xadd{l} {%0,%1|%1,%0}"
-			: "=r" (__result), "+m" (*__mem) 
-                        : "0" (__val)
+			: "=r" (__result), "=m" (*__mem) 
+                        : "0" (__val), "m"(*__mem)
                         : "memory");
   return __result;
 }
@@ -49,7 +49,9 @@
 __atomic_add (volatile _Atomic_word* __mem, int __val)
 {
   __asm__ __volatile__ ("lock; add{l} {%1,%0|%0,%1}"
-			: "+m" (*__mem) : "ir" (__val) : "memory");
+			: "=m" (*__mem)
+			: "ir" (__val), "m"(*__mem)
+			: "memory");
 }
 
 #endif /* atomicity.h */
Index: libstdc++-v3/include/bits/c++config
===================================================================
RCS file: /cvs/gcc/gcc/libstdc++-v3/include/bits/c++config,v
retrieving revision 1.574.2.657
retrieving revision 1.574.2.779
diff -u -r1.574.2.657 -r1.574.2.779
--- gcc/libstdc++-v3/include/bits/c++config	30 Sep 2004 00:16:09 -0000	1.574.2.657
+++ gcc/libstdc++-v3/include/bits/c++config	30 Jan 2005 00:16:14 -0000	1.574.2.779
@@ -35,7 +35,7 @@
 #include <bits/os_defines.h>
 
 // The current version of the C++ library in compressed ISO date format.
-#define __GLIBCPP__ 20040930
+#define __GLIBCPP__ 20050130
 
 // This is necessary until GCC supports separate template compilation.
 #define _GLIBCPP_NO_TEMPLATE_EXPORT 1
Index: libstdc++-v3/include/bits/stl_list.h
===================================================================
RCS file: /cvs/gcc/gcc/libstdc++-v3/include/bits/stl_list.h,v
retrieving revision 1.20
retrieving revision 1.20.8.1
diff -u -r1.20 -r1.20.8.1
--- gcc/libstdc++-v3/include/bits/stl_list.h	10 Sep 2002 23:19:10 -0000	1.20
+++ gcc/libstdc++-v3/include/bits/stl_list.h	21 Jan 2005 23:52:48 -0000	1.20.8.1
@@ -1,6 +1,6 @@
 // List implementation -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -108,6 +108,7 @@
     { }
   
     _List_iterator_base()
+    : _M_node()
     { }
   
     /// Walk the %list forward.
@@ -156,6 +157,7 @@
     { }
   
     _List_iterator()
+    : _List_iterator_base()
     { }
   
     _List_iterator(const iterator& __x)
Index: libstdc++-v3/include/bits/stl_tree.h
===================================================================
RCS file: /cvs/gcc/gcc/libstdc++-v3/include/bits/stl_tree.h,v
retrieving revision 1.17
retrieving revision 1.17.2.1
diff -u -r1.17 -r1.17.2.1
--- gcc/libstdc++-v3/include/bits/stl_tree.h	22 Nov 2002 18:53:53 -0000	1.17
+++ gcc/libstdc++-v3/include/bits/stl_tree.h	21 Jan 2005 23:52:49 -0000	1.17.2.1
@@ -1,6 +1,6 @@
 // RB tree implementation -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -191,7 +191,7 @@
       typedef _Rb_tree_iterator<_Val, _Ref, _Ptr> _Self;
       typedef _Rb_tree_node<_Val>* _Link_type;
       
-      _Rb_tree_iterator() {}
+      _Rb_tree_iterator() { _M_node = 0; }
       _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }
       _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }
 
